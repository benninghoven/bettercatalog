{"ast":null,"code":"#!/usr/bin/env node\n/**\n * Copyright 2021 Trent Mick.\n * Copyright 2020 Joyent Inc.\n *\n * json -- JSON love for your command line.\n *\n * See <https://github.com/trentm/json> and <https://trentm.com/json/>\n */\nvar VERSION = '11.0.0';\nvar p = console.warn;\nvar util = require('util');\nvar assert = require('assert');\nvar path = require('path');\nvar vm = require('vm');\nvar fs = require('fs');\nvar warn = console.warn;\nvar EventEmitter = require('events').EventEmitter;\n\n//--- exports for module usage\n\nexports.main = main;\nexports.getVersion = getVersion;\nexports.parseLookup = parseLookup;\n\n// As an exported API, these are still experimental:\nexports.lookupDatum = lookupDatum;\nexports.printDatum = printDatum; // DEPRECATED\n\n//---- globals and constants\n\n// Output modes.\nvar OM_JSONY = 1;\nvar OM_JSON = 2;\nvar OM_INSPECT = 3;\nvar OM_COMPACT = 4;\nvar OM_FROM_NAME = {\n  'jsony': OM_JSONY,\n  'json': OM_JSON,\n  'inspect': OM_INSPECT,\n  'compact': OM_COMPACT\n};\n\n//---- support functions\n\nfunction getVersion() {\n  return VERSION;\n}\n\n/**\n * Return a *shallow* copy of the given object.\n *\n * Only support objects that you get out of JSON, i.e. no functions.\n */\nfunction objCopy(obj) {\n  var copy;\n  if (Array.isArray(obj)) {\n    copy = obj.slice();\n  } else if (typeof obj === 'object') {\n    copy = {};\n    Object.keys(obj).forEach(function (k) {\n      copy[k] = obj[k];\n    });\n  } else {\n    copy = obj; // immutable type\n  }\n\n  return copy;\n}\nif (util.format) {\n  format = util.format;\n} else {\n  // From <https://github.com/joyent/node/blob/master/lib/util.js#L22>:\n  var formatRegExp = /%[sdj%]/g;\n  function format(f) {\n    var i;\n    if (typeof f !== 'string') {\n      var objects = [];\n      for (i = 0; i < arguments.length; i++) {\n        objects.push(util.inspect(arguments[i]));\n      }\n      return objects.join(' ');\n    }\n    i = 1;\n    var args = arguments;\n    var len = args.length;\n    var str = String(f).replace(formatRegExp, function (x) {\n      if (i >= len) return x;\n      switch (x) {\n        case '%s':\n          return String(args[i++]);\n        case '%d':\n          return Number(args[i++]);\n        case '%j':\n          return JSON.stringify(args[i++]);\n        case '%%':\n          return '%';\n        default:\n          return x;\n      }\n    });\n    for (var x = args[i]; i < len; x = args[++i]) {\n      if (x === null || typeof x !== 'object') {\n        str += ' ' + x;\n      } else {\n        str += ' ' + util.inspect(x);\n      }\n    }\n    return str;\n  }\n}\n\n/**\n * Parse the given string into a JS string. Basically: handle escapes.\n * Note that this only handles JSON escapes, which are a subset of all\n * JavaScript-supported string escapes.\n */\nfunction _parseString(s) {\n  /* JSSTYLED */\n  var quoted = '\"' + s.replace(/\\\\\"/g, '\"').replace(/\"/g, '\\\\\"') + '\"';\n  return JSON.parse(quoted);\n}\n\n// json_parse.js (<https://github.com/douglascrockford/JSON-js>)\n/* BEGIN JSSTYLED */\n// START json_parse\nvar json_parse = function () {\n  \"use strict\";\n\n  var at,\n    ch,\n    escapee = {\n      '\"': '\"',\n      \"\\\\\": \"\\\\\",\n      \"/\": \"/\",\n      b: \"\\b\",\n      f: \"\\f\",\n      n: \"\\n\",\n      r: \"\\r\",\n      t: \"\\t\"\n    },\n    text,\n    error = function (m) {\n      throw {\n        name: \"SyntaxError\",\n        message: m,\n        at: at,\n        text: text\n      };\n    },\n    next = function (c) {\n      if (c && c !== ch) {\n        error(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n      }\n      ch = text.charAt(at);\n      at += 1;\n      return ch;\n    },\n    number = function () {\n      var number,\n        string = \"\";\n      if (ch === \"-\") {\n        string = \"-\";\n        next(\"-\");\n      }\n      while (ch >= \"0\" && ch <= \"9\") {\n        string += ch;\n        next();\n      }\n      if (ch === \".\") {\n        string += \".\";\n        while (next() && ch >= \"0\" && ch <= \"9\") {\n          string += ch;\n        }\n      }\n      if (ch === \"e\" || ch === \"E\") {\n        string += ch;\n        next();\n        if (ch === \"-\" || ch === \"+\") {\n          string += ch;\n          next();\n        }\n        while (ch >= \"0\" && ch <= \"9\") {\n          string += ch;\n          next();\n        }\n      }\n      number = +string;\n      if (!isFinite(number)) {\n        error(\"Bad number\");\n      } else {\n        return number;\n      }\n    },\n    string = function () {\n      var hex,\n        i,\n        string = \"\",\n        uffff;\n      if (ch === '\"') {\n        while (next()) {\n          if (ch === '\"') {\n            next();\n            return string;\n          } else if (ch === \"\\\\\") {\n            next();\n            if (ch === \"u\") {\n              uffff = 0;\n              for (i = 0; i < 4; i += 1) {\n                hex = parseInt(next(), 16);\n                if (!isFinite(hex)) {\n                  break;\n                }\n                uffff = uffff * 16 + hex;\n              }\n              string += String.fromCharCode(uffff);\n            } else if (typeof escapee[ch] === \"string\") {\n              string += escapee[ch];\n            } else {\n              break;\n            }\n          } else {\n            string += ch;\n          }\n        }\n      }\n      error(\"Bad string\");\n    },\n    white = function () {\n      while (ch && ch <= \" \") {\n        next();\n      }\n    },\n    word = function () {\n      switch (ch) {\n        case \"t\":\n          next(\"t\");\n          next(\"r\");\n          next(\"u\");\n          next(\"e\");\n          return true;\n        case \"f\":\n          next(\"f\");\n          next(\"a\");\n          next(\"l\");\n          next(\"s\");\n          next(\"e\");\n          return false;\n        case \"n\":\n          next(\"n\");\n          next(\"u\");\n          next(\"l\");\n          next(\"l\");\n          return null;\n      }\n      error(\"Unexpected '\" + ch + \"'\");\n    },\n    value,\n    array = function () {\n      var array = [];\n      if (ch === \"[\") {\n        next(\"[\");\n        white();\n        if (ch === \"]\") {\n          next(\"]\");\n          return array;\n        }\n        while (ch) {\n          array.push(value());\n          white();\n          if (ch === \"]\") {\n            next(\"]\");\n            return array;\n          }\n          next(\",\");\n          white();\n        }\n      }\n      error(\"Bad array\");\n    },\n    object = function () {\n      var key,\n        object = {};\n      if (ch === \"{\") {\n        next(\"{\");\n        white();\n        if (ch === \"}\") {\n          next(\"}\");\n          return object;\n        }\n        while (ch) {\n          key = string();\n          white();\n          next(\":\");\n          if (Object.hasOwnProperty.call(object, key)) {\n            error('Duplicate key \"' + key + '\"');\n          }\n          object[key] = value();\n          white();\n          if (ch === \"}\") {\n            next(\"}\");\n            return object;\n          }\n          next(\",\");\n          white();\n        }\n      }\n      error(\"Bad object\");\n    };\n  value = function () {\n    white();\n    switch (ch) {\n      case \"{\":\n        return object();\n      case \"[\":\n        return array();\n      case '\"':\n        return string();\n      case \"-\":\n        return number();\n      default:\n        return ch >= \"0\" && ch <= \"9\" ? number() : word();\n    }\n  };\n  return function (source, reviver) {\n    var result;\n    text = source;\n    at = 0;\n    ch = \" \";\n    result = value();\n    white();\n    if (ch) {\n      error(\"Syntax error\");\n    }\n    return typeof reviver === \"function\" ? function walk(holder, key) {\n      var k,\n        v,\n        value = holder[key];\n      if (value && typeof value === \"object\") {\n        for (k in value) {\n          if (Object.prototype.hasOwnProperty.call(value, k)) {\n            v = walk(value, k);\n            if (v !== undefined) {\n              value[k] = v;\n            } else {\n              delete value[k];\n            }\n          }\n        }\n      }\n      return reviver.call(holder, key, value);\n    }({\n      \"\": result\n    }, \"\") : result;\n  };\n}();\n\n// END json_parse\n/* END JSSTYLED */\n\nfunction printHelp() {\n  /* BEGIN JSSTYLED */\n  var w = console.log;\n  w('Usage:');\n  w('  <something generating JSON on stdout> | json [OPTIONS] [LOOKUPS...]');\n  w('  json -f FILE [OPTIONS] [LOOKUPS...]');\n  w('');\n  w('Pipe in your JSON for pretty-printing, JSON validation, filtering, ');\n  w('and modification. Supply one or more `LOOKUPS` to extract a ');\n  w('subset of the JSON. HTTP header blocks are skipped by default.');\n  w('Roughly in order of processing, features are:');\n  w('');\n  w('Grouping:');\n  w('  Use \"-g\" or \"--group\" to group adjacent objects, separated by');\n  w('  by no space or a by a newline, or adjacent arrays, separate by');\n  w('  by a newline. This can be helpful for, e.g.: ');\n  w('     $ cat *.json | json -g ... ');\n  w('  and similar.');\n  w('');\n  w('Execution:');\n  w('  Use the \"-e CODE\" option to execute JavaScript code on the input JSON.');\n  w('     $ echo \\'{\"name\":\"trent\",\"age\":38}\\' | json -e \\'this.age++\\'');\n  w('     {');\n  w('       \"name\": \"trent\",');\n  w('       \"age\": 39');\n  w('     }');\n  w('  If input is an array, this will automatically process each');\n  w('  item separately.');\n  w('');\n  w('Conditional filtering:');\n  w('  Use the \"-c CODE\" option to filter the input JSON.');\n  w('     $ echo \\'[{\"age\":38},{\"age\":4}]\\' | json -c \\'this.age>21\\'');\n  w('     [{\\'age\\':38}]');\n  w('  If input is an array, this will automatically process each');\n  w('  item separately. Note: \"CODE\" is JavaScript code.');\n  w('');\n  w('Lookups:');\n  w('  Use lookup arguments to extract particular values:');\n  w('     $ echo \\'{\"name\":\"trent\",\"age\":38}\\' | json name');\n  w('     trent');\n  w('');\n  w('  Use \"-a\" for *array processing* of lookups and *tabular output*:');\n  w('     $ echo \\'{\"name\":\"trent\",\"age\":38}\\' | json name age');\n  w('     trent');\n  w('     38');\n  w('     $ echo \\'[{\"name\":\"trent\",\"age\":38},');\n  w('               {\"name\":\"ewan\",\"age\":4}]\\' | json -a name age');\n  w('     trent 38');\n  w('     ewan 4');\n  w('');\n  w('In-place editing:');\n  w('  Use \"-I, --in-place\" to edit a file in place:');\n  w('     $ json -I -f config.json  # reformat');\n  w('     $ json -I -f config.json -c \\'this.logLevel=\"debug\"\\' # add field');\n  w('');\n  w('Pretty-printing:');\n  w('  Output is \"jsony\" by default: 2-space indented JSON, except a');\n  w('  single string value is printed without quotes.');\n  w('     $ echo \\'{\"name\": \"trent\", \"age\": 38}\\' | json');\n  w('     {');\n  w('       \"name\": \"trent\",');\n  w('       \"age\": 38');\n  w('     }');\n  w('     $ echo \\'{\"name\": \"trent\", \"age\": 38}\\' | json name');\n  w('     trent');\n  w('');\n  w(\"  Use '-j' or '-o json' for explicit JSON, '-o json-N' for N-space indent:\");\n  w('     $ echo \\'{\"name\": \"trent\", \"age\": 38}\\' | json -o json-0');\n  w('     {\"name\":\"trent\",\"age\":38}');\n  w('');\n  w('Options:');\n  w('  -h, --help    Print this help info and exit.');\n  w('  --version     Print version of this command and exit.');\n  w('  -q, --quiet   Don\\'t warn if input isn\\'t valid JSON.');\n  w('');\n  w('  -f FILE       Path to a file to process. If not given, then');\n  w('                stdin is used.');\n  w('  -I, --in-place  In-place edit of the file given with \"-f\".');\n  w('                Lookups are not allow with in-place editing');\n  w('                because it makes it too easy to lose content.');\n  w('');\n  w('  -H            Drop any HTTP header block (as from `curl -i ...`).');\n  w('  -g, --group   Group adjacent objects or arrays into an array.');\n  w('  --merge       Merge adjacent objects into one. Keys in last ');\n  w('                object win.');\n  w('  --deep-merge  Same as \"--merge\", but will recurse into objects ');\n  w('                under the same key in both.');\n  w('  -a, --array   Process input as an array of separate inputs');\n  w('                and output in tabular form.');\n  w('  -A            Process input as a single object, i.e. stop');\n  w('                \"-e\" and \"-c\" automatically processing each');\n  w('                item of an input array.');\n  w('  -d DELIM      Delimiter char for tabular output (default is \" \").');\n  w('  -D DELIM      Delimiter char between lookups (default is \".\"). E.g.:');\n  w('                    $ echo \\'{\"a.b\": {\"b\": 1}}\\' | json -D / a.b/b');\n  w('');\n  w('  -M, --items   Itemize an object into an array of ');\n  w('                    {\"key\": <key>, \"value\": <value>}');\n  w('                objects for easier processing.');\n  w('');\n  w('  -e CODE       Execute the given JavaScript code on the input. If input');\n  w('                is an array, then each item of the array is processed');\n  w('                separately (use \"-A\" to override).');\n  w('  -c CODE       Filter the input with JavaScript `CODE`. If `CODE`');\n  w('                returns false-y, then the item is filtered out. If');\n  w('                input is an array, then each item of the array is ');\n  w('                processed separately (use \"-A\" to override).');\n  w('');\n  w('  -k, --keys    Output the input object\\'s keys.');\n  w('  -n, --validate  Just validate the input (no processing or output).');\n  w('                Use with \"-q\" for silent validation (exit status).');\n  w('');\n  w('  -o, --output MODE');\n  w('                Specify an output mode. One of:');\n  w('                    jsony (default): JSON with string quotes elided');\n  w('                    json: JSON output, 2-space indent');\n  w('                    json-N: JSON output, N-space indent, e.g. \"json-4\"');\n  w('                    inspect: node.js `util.inspect` output');\n  w('  -i            Shortcut for `-o inspect`');\n  w('  -j            Shortcut for `-o json`');\n  w('  -0, -2, -4    Set indentation to the given value w/o setting MODE.');\n  w('                    -0   =>  -o jsony-0');\n  w('                    -4   =>  -o jsony-4');\n  w('                    -j0  =>  -o json-0');\n  w('');\n  w('See <http://trentm.com/json> for more docs and ');\n  w('<https://github.com/trentm/json> for project details.');\n  /* END JSSTYLED */\n}\n\n/**\n * Parse the command-line options and arguments into an object.\n *\n *    {\n *      'args': [...]       // arguments\n *      'help': true,       // true if '-h' option given\n *       // etc.\n *    }\n *\n * @return {Object} The parsed options. `.args` is the argument list.\n * @throws {Error} If there is an error parsing argv.\n */\nfunction parseArgv(argv) {\n  var parsed = {\n    args: [],\n    help: false,\n    quiet: false,\n    dropHeaders: false,\n    exeSnippets: [],\n    condSnippets: [],\n    outputMode: OM_JSONY,\n    jsonIndent: 2,\n    array: null,\n    delim: ' ',\n    lookupDelim: '.',\n    items: false,\n    outputKeys: false,\n    group: false,\n    merge: null,\n    // --merge -> 'shallow', --deep-merge -> 'deep'\n    inputFiles: [],\n    validate: false,\n    inPlace: false\n  };\n\n  // Turn '-iH' into '-i -H', except for argument-accepting options.\n  var args = argv.slice(2); // drop ['node', 'scriptname']\n  var newArgs = [];\n  var optTakesArg = {\n    'd': true,\n    'o': true,\n    'D': true\n  };\n  for (var i = 0; i < args.length; i++) {\n    if (args[i] === '--') {\n      newArgs = newArgs.concat(args.slice(i));\n      break;\n    }\n    if (args[i].charAt(0) === '-' && args[i].charAt(1) !== '-' && args[i].length > 2) {\n      var splitOpts = args[i].slice(1).split('');\n      for (var j = 0; j < splitOpts.length; j++) {\n        newArgs.push('-' + splitOpts[j]);\n        if (optTakesArg[splitOpts[j]]) {\n          var optArg = splitOpts.slice(j + 1).join('');\n          if (optArg.length) {\n            newArgs.push(optArg);\n          }\n          break;\n        }\n      }\n    } else {\n      newArgs.push(args[i]);\n    }\n  }\n  args = newArgs;\n  endOfOptions = false;\n  while (args.length > 0) {\n    var arg = args.shift();\n    if (endOfOptions) {\n      parsed.args.push(arg);\n      break;\n    }\n    switch (arg) {\n      case '--':\n        endOfOptions = true;\n        break;\n      case '-h': // display help and exit\n      case '--help':\n        parsed.help = true;\n        break;\n      case '--version':\n        parsed.version = true;\n        break;\n      case '-q':\n      case '--quiet':\n        parsed.quiet = true;\n        break;\n      case '-H':\n        // drop any headers\n        parsed.dropHeaders = true;\n        break;\n      case '-o':\n      case '--output':\n        var name = args.shift();\n        if (!name) {\n          throw new Error('no argument given for \"-o|--output\" option');\n        }\n        var idx = name.lastIndexOf('-');\n        if (idx !== -1) {\n          var indent = name.slice(idx + 1);\n          if (/^\\d+$/.test(indent)) {\n            parsed.jsonIndent = Number(indent);\n            name = name.slice(0, idx);\n          } else if (indent === 'tab') {\n            parsed.jsonIndent = '\\t';\n            name = name.slice(0, idx);\n          }\n        }\n        parsed.outputMode = OM_FROM_NAME[name];\n        if (parsed.outputMode === undefined) {\n          throw new Error('unknown output mode: \"' + name + '\"');\n        }\n        break;\n      case '-0':\n        parsed.jsonIndent = 0;\n        break;\n      case '-2':\n        parsed.jsonIndent = 2;\n        break;\n      case '-4':\n        parsed.jsonIndent = 4;\n        break;\n      case '-I':\n      case '--in-place':\n        parsed.inPlace = true;\n        break;\n      case '-i':\n        // output with util.inspect\n        parsed.outputMode = OM_INSPECT;\n        break;\n      case '-j':\n        // output with JSON.stringify\n        parsed.outputMode = OM_JSON;\n        break;\n      case '-a':\n      case '--array':\n        parsed.array = true;\n        break;\n      case '-A':\n        parsed.array = false;\n        break;\n      case '-d':\n        var outputDelim = args.shift();\n        try {\n          parsed.delim = _parseString(outputDelim);\n        } catch (parseErr) {\n          throw new Error(format('could not parse delim \"%s\": %s', outputDelim, parseErr.message));\n        }\n        break;\n      case '-D':\n        parsed.lookupDelim = args.shift();\n        if (parsed.lookupDelim.length !== 1) {\n          throw new Error(format('invalid lookup delim \"%s\" (must be a single char)', parsed.lookupDelim));\n        }\n        break;\n      case '-e':\n      case '-E':\n        // DEPRECATED in v9\n        parsed.exeSnippets.push(args.shift());\n        break;\n      case '-c':\n      case '-C':\n        // DEPRECATED in v9\n        parsed.condSnippets.push(args.shift());\n        break;\n      case '-M':\n      case '--items':\n        parsed.items = true;\n        break;\n      case '-k':\n      case '--keys':\n        parsed.outputKeys = true;\n        break;\n      case '-g':\n      case '--group':\n        parsed.group = true;\n        break;\n      case '--merge':\n        parsed.merge = 'shallow';\n        break;\n      case '--deep-merge':\n        parsed.merge = 'deep';\n        break;\n      case '-f':\n        parsed.inputFiles.push(args.shift());\n        break;\n      case '-n':\n      case '--validate':\n        parsed.validate = true;\n        break;\n      default:\n        // arguments\n        if (!endOfOptions && arg.length > 0 && arg[0] === '-') {\n          throw new Error('unknown option \"' + arg + '\"');\n        }\n        parsed.args.push(arg);\n        break;\n    }\n  }\n  if (parsed.group && parsed.merge) {\n    throw new Error('cannot use -g|--group and --merge options together');\n  }\n  if (parsed.outputKeys && parsed.args.length > 0) {\n    throw new Error('cannot use -k|--keys option and lookup arguments together');\n  }\n  if (parsed.inPlace && parsed.inputFiles.length !== 1) {\n    throw new Error('must specify exactly one file with \"-f FILE\" to ' + 'use -I/--in-place');\n  }\n  if (parsed.inPlace && parsed.args.length > 0) {\n    throw new Error('lookups cannot be specified with in-place editing ' + '(-I/--in-place), too easy to lose content');\n  }\n  return parsed;\n}\n\n/**\n * Streams chunks from given file paths or stdin.\n *\n * @param opts {Object} Parsed options.\n * @returns {Object} An emitter that emits 'chunk', 'error', and 'end'.\n *    - `emit('chunk', chunk, [obj])` where chunk is a complete block of JSON\n *       ready to parse. If `obj` is provided, it is the already parsed\n *       JSON.\n *    - `emit('error', error)` when an underlying stream emits an error\n *    - `emit('end')` when all streams are done\n */\nfunction chunkEmitter(opts) {\n  var emitter = new EventEmitter();\n  var streaming = true;\n  var chunks = [];\n  var leftover = '';\n  var finishedHeaders = false;\n  function stripHeaders(s) {\n    // Take off a leading HTTP header if any and pass it through.\n    while (true) {\n      if (s.slice(0, 5) === 'HTTP/') {\n        var index = s.indexOf('\\r\\n\\r\\n');\n        var sepLen = 4;\n        if (index == -1) {\n          index = s.indexOf('\\n\\n');\n          sepLen = 2;\n        }\n        if (index != -1) {\n          if (!opts.dropHeaders) {\n            emit(s.slice(0, index + sepLen));\n          }\n          var is100Continue = s.slice(0, 21) === 'HTTP/1.1 100 Continue';\n          s = s.slice(index + sepLen);\n          if (is100Continue) {\n            continue;\n          }\n          finishedHeaders = true;\n        }\n      } else {\n        finishedHeaders = true;\n      }\n      break;\n    }\n    //console.warn('stripHeaders done, finishedHeaders=%s', finishedHeaders)\n    return s;\n  }\n  function emitChunks(block, emitter) {\n    //console.warn('emitChunks start: block=\"%s\"', block)\n    /* JSSTYLED */\n    var splitter = /(})(\\s*\\n\\s*)?({\\s*\")/;\n    var leftTrimmedBlock = block.trimLeft();\n    if (leftTrimmedBlock && leftTrimmedBlock[0] !== '{') {\n      // Currently only support streaming consecutive *objects*.\n      streaming = false;\n      chunks.push(block);\n      return '';\n    }\n    /**\n     * Example:\n     * > '{\"a\":\"b\"}\\n{\"a\":\"b\"}\\n{\"a\":\"b\"}'.split(/(})(\\s*\\n\\s*)?({\\s*\")/)\n     * [ '{\"a\":\"b\"',\n     *   '}',\n     *   '\\n',\n     *   '{\"',\n     *   'a\":\"b\"',\n     *   '}',\n     *   '\\n',\n     *   '{\"',\n     *   'a\":\"b\"}' ]\n     */\n    var bits = block.split(splitter);\n    //console.warn('emitChunks: bits (length %d): %j', bits.length, bits);\n    if (bits.length === 1) {\n      /*\n       * An unwanted side-effect of using a regex to find\n       * newline-separated objects *with a regex*, is that we are looking\n       * for the end of one object leading into the start of a another.\n       * That means that we can end up buffering a complete object until\n       * a subsequent one comes in. If the input stream has large delays\n       * between objects, then this is unwanted buffering.\n       *\n       * One solution would be full stream parsing of objects a la\n       * <https://github.com/creationix/jsonparse>. This would nicely\n       * also remove the artibrary requirement that the input stream be\n       * newline separated. jsonparse apparently has some issues tho, so\n       * I don't want to use it right now. It also isn't *small* so not\n       * sure I want to inline it (`json` doesn't have external deps).\n       *\n       * An alternative: The block we have so far one of:\n       * 1. some JSON that we don't support grouping (e.g. a stream of\n       *    non-objects),\n       * 2. a JSON object fragment, or\n       * 3. a complete JSON object (with a possible trailing '{')\n       *\n       * If #3, then we can just emit this as a chunk right now.\n       *\n       * TODO(PERF): Try out avoiding the first more complete regex split\n       * for a presumed common case of single-line newline-separated JSON\n       * objects (e.g. a bunyan log).\n       */\n      // An object must end with '}'. This is an early out to avoid\n      // `JSON.parse` which I'm *presuming* is slower.\n      var trimmed = block.split(/\\s*\\r?\\n/)[0];\n      if (trimmed[trimmed.length - 1] === '}') {\n        var obj;\n        try {\n          obj = JSON.parse(block);\n        } catch (e) {\n          /* pass through */\n        }\n        if (obj !== undefined) {\n          // Emit the parsed `obj` to avoid re-parsing it later.\n          emitter.emit('chunk', block, obj);\n          block = '';\n        }\n      }\n      return block;\n    } else {\n      var n = bits.length - 2;\n      var s;\n      s = bits[0] + bits[1];\n      emitter.emit('chunk', s, JSON.parse(s));\n      for (var i = 3; i < n; i += 4) {\n        s = bits[i] + bits[i + 1] + bits[i + 2];\n        emitter.emit('chunk', s, JSON.parse(s));\n      }\n      return bits[n] + bits[n + 1];\n    }\n  }\n  function addDataListener(stream) {\n    stream.on('data', function (chunk) {\n      var s = leftover + chunk;\n      if (!finishedHeaders) {\n        s = stripHeaders(s);\n      }\n      if (!finishedHeaders) {\n        leftover = s;\n      } else {\n        if (!streaming) {\n          chunks.push(chunk);\n          return;\n        }\n        if (chunk.lastIndexOf('\\n') >= 0) {\n          leftover = emitChunks(s, emitter);\n        } else {\n          leftover = s;\n        }\n      }\n    });\n  }\n  if (opts.inputFiles.length > 0) {\n    // Stream each file in order.\n    var i = 0;\n    function addErrorListener(file) {\n      file.on('error', function (err) {\n        emitter.emit('error', format('could not read \"%s\": %s', opts.inputFiles[i], e));\n      });\n    }\n    function addEndListener(file) {\n      file.on('end', function () {\n        if (i < opts.inputFiles.length) {\n          var next = opts.inputFiles[i++];\n          var nextFile = fs.createReadStream(next, {\n            encoding: 'utf8'\n          });\n          addErrorListener(nextFile);\n          addEndListener(nextFile);\n          addDataListener(nextFile);\n        } else {\n          if (!streaming) {\n            emitter.emit('chunk', chunks.join(''));\n          } else if (leftover) {\n            leftover = emitChunks(leftover, emitter);\n            emitter.emit('chunk', leftover);\n          }\n          emitter.emit('end');\n        }\n      });\n    }\n    var first = fs.createReadStream(opts.inputFiles[i++], {\n      encoding: 'utf8'\n    });\n    addErrorListener(first);\n    addEndListener(first);\n    addDataListener(first);\n  } else {\n    // Streaming from stdin.\n    var stdin = process.openStdin();\n    stdin.setEncoding('utf8');\n    addDataListener(stdin);\n    stdin.on('end', function () {\n      if (!streaming) {\n        emitter.emit('chunk', chunks.join(''));\n      } else if (leftover) {\n        leftover = emitChunks(leftover, emitter);\n        emitter.emit('chunk', leftover);\n      }\n      emitter.emit('end');\n    });\n  }\n  return emitter;\n}\n\n/**\n * Get input from either given file paths or stdin. If `opts.inPlace` then\n * this calls the callback once for each `opts.inputFiles`.\n *\n * @param opts {Object} Parsed options.\n * @param callback {Function} `function (err, content, filename)` where err\n *    is an error string if there was a problem, `content` is the read\n *    content and `filename` is the associated file name from which content\n *    was loaded if applicable.\n */\nfunction getInput(opts, callback) {\n  if (opts.inputFiles.length === 0) {\n    // Read from stdin.\n    var chunks = [];\n    var stdin = process.openStdin();\n    stdin.setEncoding('utf8');\n    stdin.on('data', function (chunk) {\n      chunks.push(chunk);\n    });\n    stdin.on('end', function () {\n      callback(null, chunks.join(''));\n    });\n  } else if (opts.inPlace) {\n    for (var i = 0; i < opts.inputFiles.length; i++) {\n      var file = opts.inputFiles[i];\n      var content;\n      try {\n        content = fs.readFileSync(file, 'utf8');\n      } catch (e) {\n        callback(e, null, file);\n      }\n      if (content) {\n        callback(null, content, file);\n      }\n    }\n  } else {\n    // Read input files.\n    var i = 0;\n    var chunks = [];\n    try {\n      for (; i < opts.inputFiles.length; i++) {\n        chunks.push(fs.readFileSync(opts.inputFiles[i], 'utf8'));\n      }\n    } catch (e) {\n      return callback(format('could not read \"%s\": %s', opts.inputFiles[i], e));\n    }\n    callback(null, chunks.join(''), opts.inputFiles.length === 1 ? opts.inputFiles[0] : undefined);\n  }\n}\nfunction isInteger(s) {\n  return s.search(/^-?[0-9]+$/) == 0;\n}\n\n/**\n * Parse a lookup string into a list of lookup bits. E.g.:\n *\n *    'a.b.c' -> [\"a\",\"b\",\"c\"]\n *    'b[\"a\"]' -> [\"b\",\"a\"]\n *\n * Note: v10 made a backward incompatible change here that limits the supported\n * *bracketed* lookups. A bracketed section of a lookup must be of one of the\n * following forms:\n *      [\"...\"]\n *      ['...']\n *      [`...`]\n * The quoted string is not evaluated, other than supporting a subset of JS\n * string escapes (e.g. \\', \\\", \\n; but not unicode char escapes).\n * See the long block comment below in this function for details.\n *\n * Optionally receives an alternative lookup delimiter (other than '.')\n */\nfunction parseLookup(lookup, lookupDelim) {\n  var debug = function () {};\n  // var debug = console.warn;\n\n  var bits = [];\n  debug('\\n*** ' + lookup + ' ***');\n  bits = [];\n  lookupDelim = lookupDelim || '.';\n  var bit = '';\n  var states = [null];\n  var escaped = false;\n  var ch = null;\n  for (var i = 0; i < lookup.length; ++i) {\n    var ch = lookup[i];\n    debug('-- i=' + i + ', ch=' + JSON.stringify(ch) + ' escaped=' + JSON.stringify(escaped));\n    debug('states: ' + JSON.stringify(states));\n\n    // Handle a *limited subset* of JS string escapes.\n    // JSSTYLED\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#Escape_notation\n    var SUPPORTED_ESCAPES = {\n      '\\'': '\\'',\n      '\\\"': '\\\"',\n      '\\`': '\\`',\n      '\\\\': '\\\\',\n      'n': '\\n',\n      'r': '\\r',\n      't': '\\t',\n      'v': '\\v',\n      'b': '\\b',\n      'f': '\\f'\n    };\n    if (ch === '\\\\' && i + 1 < lookup.length) {\n      var nextCh = lookup[i + 1];\n      var escapedCh = SUPPORTED_ESCAPES[nextCh];\n      if (escapedCh !== undefined) {\n        debug('escaped: %j -> %j', ch + nextCh, escapedCh);\n        bit += escapedCh;\n        i++;\n        continue;\n      }\n    }\n    switch (states[states.length - 1]) {\n      case null:\n        switch (ch) {\n          case '\"':\n          case '\\'':\n            states.push(ch);\n            bit += ch;\n            break;\n          case '[':\n            states.push(ch);\n            if (bit !== '') {\n              bits.push(bit);\n              bit = '';\n            }\n            bit += ch;\n            break;\n          case lookupDelim:\n            if (bit !== '') {\n              bits.push(bit);\n              bit = '';\n            }\n            break;\n          default:\n            bit += ch;\n            break;\n        }\n        break;\n      case '[':\n        bit += ch;\n        switch (ch) {\n          case '\"':\n          case '\\'':\n          case '[':\n            states.push(ch);\n            break;\n          case ']':\n            states.pop();\n            if (states[states.length - 1] === null) {\n              // `bit` is a bracketed string, `[...]`.\n              //\n              // The *intent* is to allow specifying an object key\n              // that would otherwise get interpreted by `json`s\n              // LOOKUP parsing -- typically if the key has a `.` in it.\n              //\n              // Up to and including json v9, this was handled by eval'ing\n              // the given string inside the brackets (via\n              // `vm.runInNewContext`). However, trentm/json#144 shows\n              // that this is an avenue for command injection. It was\n              // never made clear in `json` documentation that one\n              // should never use user-provided strings for LOOKUPs, so\n              // we should close this vulnerability.\n              //\n              // Expected usage and documented examples are like this:\n              //      [\"foo.bar\"]\n              //      ['foo.bar']\n              // However, older implementation of eval'ing meant that\n              // things like the following worked:\n              //      [42]\n              //      [\"my\" + \"key\"]\n              //      [(function () { return \"mykey\" })()]\n              //\n              // The documentation was never explicit about denying\n              // expressions would work. v10 **breaks compatibility**\n              // to only support a bracketed string:\n              //      [\"...\"]\n              //      ['...']\n              //      [`...`]   # note: no var interpolation is done\n              // and error otherwise.\n              var VALID_QUOTES = '\"\\'`';\n              var sQuote = bit[1];\n              var eQuote = bit.slice(-2, -1);\n              if (VALID_QUOTES.indexOf(sQuote) === -1 || sQuote !== eQuote) {\n                throw new Error(format('invalid bracketed lookup ' + 'string: %j (must be of the form [\\'...\\'], ' + '[\"...\"], or [`...`])', bit));\n              }\n              bits.push(bit.slice(2, -2));\n              bit = '';\n            }\n            break;\n        }\n        break;\n      case '\"':\n        bit += ch;\n        switch (ch) {\n          case '\"':\n            states.pop();\n            if (states[states.length - 1] === null) {\n              bits.push(bit);\n              bit = '';\n            }\n            break;\n        }\n        break;\n      case '\\'':\n        bit += ch;\n        switch (ch) {\n          case '\\'':\n            states.pop();\n            if (states[states.length - 1] === null) {\n              bits.push(bit);\n              bit = '';\n            }\n            break;\n        }\n        break;\n    }\n    debug('bit: ' + JSON.stringify(bit));\n    debug('bits: ' + JSON.stringify(bits));\n  }\n  if (bit !== '') {\n    bits.push(bit);\n    bit = '';\n  }\n\n  // Negative-intify: strings that are negative ints we change to a Number for\n  // special handling in `lookupDatum`: Python-style negative array indexing.\n  var negIntPat = /^-\\d+$/;\n  for (var i = 0; i < bits.length; i++) {\n    if (negIntPat.test(bits[i])) {\n      bits[i] = Number(bits[i]);\n    }\n  }\n  debug(JSON.stringify(lookup) + ' -> ' + JSON.stringify(bits));\n  return bits;\n}\n\n/**\n * Parse the given stdin input into:\n *  {\n *    'error': ... error object if there was an error ...,\n *    'datum': ... parsed object if content was JSON ...\n *   }\n *\n * @param buffer {String} The text to parse as JSON.\n * @param obj {Object} Optional. Set when in streaming mode to avoid\n *    re-interpretation of `group`. Also avoids reparsing.\n * @param group {Boolean} Default false. If true, then non-JSON input\n *    will be attempted to be 'arrayified' (see inline comment).\n * @param merge {Boolean} Default null. Can be 'shallow' or 'deep'. An\n *    attempt will be made to interpret the input as adjacent objects to\n *    be merged, last key wins. See inline comment for limitations.\n */\nfunction parseInput(buffer, obj, group, merge) {\n  if (obj) {\n    return {\n      datum: obj\n    };\n  } else if (group) {\n    /**\n     * Special case: Grouping (previously called auto-arrayification)\n     * of unjoined list of objects:\n     *    {\"one\": 1}{\"two\": 2}\n     * and auto-concatenation of unjoined list of arrays:\n     *    [\"a\", \"b\"][\"c\", \"d\"]\n     *\n     * This can be nice to process a stream of JSON objects generated from\n     * multiple calls to another tool or `cat *.json | json`.\n     *\n     * Rules:\n     * - Only JS objects and arrays. Don't see strong need for basic\n     *   JS types right now and this limitation simplifies.\n     * - The break between JS objects has to include a newline:\n     *      {\"one\": 1}\n     *      {\"two\": 2}\n     *   or no spaces at all:\n     *      {\"one\": 1}{\"two\": 2}\n     *   I.e., not this:\n     *      {\"one\": 1}  {\"two\": 2}\n     *   This condition should be fine for typical use cases and ensures\n     *   no false matches inside JS strings.\n     * - The break between JS *arrays* has to include a newline:\n     *      [\"one\", \"two\"]\n     *      [\"three\"]\n     *   The 'no spaces' case is NOT supported for JS arrays as of v6.0.0\n     *   because <https://github.com/trentm/json/issues/55> shows that that\n     *   is not safe.\n     */\n    var newBuffer = buffer;\n    /* JSSTYLED */\n    [/(})\\s*\\n\\s*({)/g, /(})({\")/g].forEach(function (pat) {\n      newBuffer = newBuffer.replace(pat, '$1,\\n$2');\n    });\n    [/(\\])\\s*\\n\\s*(\\[)/g].forEach(function (pat) {\n      newBuffer = newBuffer.replace(pat, ',\\n');\n    });\n    newBuffer = newBuffer.trim();\n    if (newBuffer[0] !== '[') {\n      newBuffer = '[\\n' + newBuffer;\n    }\n    if (newBuffer.slice(-1) !== ']') {\n      newBuffer = newBuffer + '\\n]\\n';\n    }\n    try {\n      return {\n        datum: JSON.parse(newBuffer)\n      };\n    } catch (e2) {\n      return {\n        error: e2\n      };\n    }\n  } else if (merge) {\n    // See the 'Rules' above for limitations on boundaries for 'adjacent'\n    // objects: KISS.\n    var newBuffer = buffer;\n    /* JSSTYLED */\n    [/(})\\s*\\n\\s*({)/g, /(})({\")/g].forEach(function (pat) {\n      newBuffer = newBuffer.replace(pat, '$1,\\n$2');\n    });\n    newBuffer = '[\\n' + newBuffer + '\\n]\\n';\n    var objs;\n    try {\n      objs = JSON.parse(newBuffer);\n    } catch (e) {\n      return {\n        error: e\n      };\n    }\n    var merged = objs[0];\n    if (merge === 'shallow') {\n      for (var i = 1; i < objs.length; i++) {\n        var obj = objs[i];\n        Object.keys(obj).forEach(function (k) {\n          merged[k] = obj[k];\n        });\n      }\n    } else if (merge === 'deep') {\n      function deepExtend(a, b) {\n        Object.keys(b).forEach(function (k) {\n          if (a[k] && b[k] && toString.call(a[k]) === '[object Object]' && toString.call(b[k]) === '[object Object]') {\n            deepExtend(a[k], b[k]);\n          } else {\n            a[k] = b[k];\n          }\n        });\n      }\n      for (var i = 1; i < objs.length; i++) {\n        deepExtend(merged, objs[i]);\n      }\n    } else {\n      throw new Error(format('unknown value for \"merge\": \"%s\"', merge));\n    }\n    return {\n      datum: merged\n    };\n  } else {\n    try {\n      return {\n        datum: JSON.parse(buffer)\n      };\n    } catch (e) {\n      return {\n        error: e\n      };\n    }\n  }\n}\n\n/**\n * Apply a lookup to the given datum.\n *\n * @argument datum {Object}\n * @argument lookup {Array} The parsed lookup (from\n *    `parseLookup(<string>, <string>)`). Might be empty.\n * @returns {Object} The result of the lookup.\n */\nfunction lookupDatum(datum, lookup) {\n  var d = datum;\n  for (var i = 0; i < lookup.length; i++) {\n    var bit = lookup[i];\n    if (d === null) {\n      return undefined;\n    } else if (typeof bit === 'number' && bit < 0) {\n      d = d[d.length + bit];\n    } else {\n      d = d[bit];\n    }\n    if (d === undefined) {\n      return undefined;\n    }\n  }\n  return d;\n}\n\n/**\n * Output the given datasets.\n *\n * @param datasets {Array} Array of data sets to print, in the form:\n *    `[ [<datum>, <sep>, <alwaysPrintSep>], ... ]`\n * @param filename {String} The filename to which to write the output. If\n *    not set, then emit to stdout.\n * @param headers {String} The HTTP header block string, if any, to emit\n *    first.\n * @param opts {Object} Parsed tool options.\n */\nfunction printDatasets(datasets, filename, headers, opts) {\n  var isTTY = filename ? false : process.stdout.isTTY;\n  var write = emit;\n  if (filename) {\n    var tmpPath = path.resolve(path.dirname(filename), format('.%s-json-%s-%s.tmp', path.basename(filename), process.pid, Date.now()));\n    var stats = fs.statSync(filename);\n    var f = fs.createWriteStream(tmpPath, {\n      encoding: 'utf8',\n      mode: stats.mode\n    });\n    write = f.write.bind(f);\n  }\n  if (headers && headers.length > 0) {\n    write(headers);\n  }\n  for (var i = 0; i < datasets.length; i++) {\n    var dataset = datasets[i];\n    var output = stringifyDatum(dataset[0], opts, isTTY);\n    var sep = dataset[1];\n    if (output && output.length) {\n      write(output);\n      write(sep);\n    } else if (dataset[2]) {\n      write(sep);\n    }\n  }\n  if (filename) {\n    f.on('open', function () {\n      f.end();\n      fs.renameSync(tmpPath, filename);\n      if (!opts.quiet) {\n        warn('json: updated \"%s\" in-place', filename);\n      }\n    });\n  }\n}\n\n/**\n * Stringify the given datum according to the given output options.\n */\nfunction stringifyDatum(datum, opts, isTTY) {\n  var output = null;\n  switch (opts.outputMode) {\n    case OM_INSPECT:\n      output = util.inspect(datum, false, Infinity, isTTY);\n      break;\n    case OM_JSON:\n      if (typeof datum !== 'undefined') {\n        output = JSON.stringify(datum, null, opts.jsonIndent);\n      }\n      break;\n    case OM_COMPACT:\n      // Dev Note: A still relatively experimental attempt at a more\n      // compact ouput somewhat a la Python's repr of a dict. I.e. try to\n      // fit elements on one line as much as reasonable.\n      if (datum === undefined) {\n        // pass\n      } else if (Array.isArray(datum)) {\n        var bits = ['[\\n'];\n        datum.forEach(function (d) {\n          bits.push('  ');\n          bits.push(JSON.stringify(d, null, 0).replace( /* JSSTYLED */\n          /,\"(?![,:])/g, ', \"'));\n          bits.push(',\\n');\n        });\n        bits.push(bits.pop().slice(0, -2) + '\\n'); // drop last comma\n        bits.push(']');\n        output = bits.join('');\n      } else {\n        output = JSON.stringify(datum, null, 0);\n      }\n      break;\n    case OM_JSONY:\n      if (typeof datum === 'string') {\n        output = datum;\n      } else if (typeof datum !== 'undefined') {\n        output = JSON.stringify(datum, null, opts.jsonIndent);\n      }\n      break;\n    default:\n      throw new Error('unknown output mode: ' + opts.outputMode);\n  }\n  return output;\n}\n\n/**\n * Print out a single result, considering input options.\n *\n * @deprecated\n */\nfunction printDatum(datum, opts, sep, alwaysPrintSep) {\n  var output = stringifyDatum(datum, opts);\n  if (output && output.length) {\n    emit(output);\n    emit(sep);\n  } else if (alwaysPrintSep) {\n    emit(sep);\n  }\n}\nvar stdoutFlushed = true;\nfunction emit(s) {\n  // TODO:PERF If this is try/catch is too slow (too granular): move up to\n  //    mainline and be sure to only catch this particular error.\n  if (drainingStdout) {\n    return;\n  }\n  try {\n    stdoutFlushed = process.stdout.write(s);\n  } catch (e) {\n    // Handle any exceptions in stdout writing in the 'error' event above.\n  }\n}\nprocess.stdout.on('error', function (err) {\n  if (err.code === 'EPIPE') {\n    // See <https://github.com/trentm/json/issues/9>.\n    drainStdoutAndExit(0);\n  } else {\n    warn(err);\n    drainStdoutAndExit(1);\n  }\n});\n\n/**\n * A hacked up version of 'process.exit' that will first drain stdout\n * before exiting. *WARNING: This doesn't stop event processing.* IOW,\n * callers have to be careful that code following this call isn't\n * accidentally executed.\n *\n * In node v0.6 \"process.stdout and process.stderr are blocking when they\n * refer to regular files or TTY file descriptors.\" However, this hack might\n * still be necessary in a shell pipeline.\n */\nvar drainingStdout = false;\nfunction drainStdoutAndExit(code) {\n  if (drainingStdout) {\n    return;\n  }\n  drainingStdout = true;\n  process.stdout.on('drain', function () {\n    process.exit(code);\n  });\n  process.stdout.on('close', function () {\n    process.exit(code);\n  });\n  if (stdoutFlushed) {\n    process.exit(code);\n  }\n}\n\n/**\n * Return a function for the given JS code that returns.\n *\n * If no 'return' in the given javascript snippet, then assume we are a single\n * statement and wrap in 'return (...)'. This is for convenience for short\n * '-c ...' snippets.\n */\nfunction funcWithReturnFromSnippet(js) {\n  // auto-\"return\"\n  if (js.indexOf('return') === -1) {\n    if (js.substring(js.length - 1) === ';') {\n      js = js.substring(0, js.length - 1);\n    }\n    js = 'return (' + js + ')';\n  }\n  return new Function(js);\n}\n\n//---- mainline\n\nfunction main(argv) {\n  var opts;\n  try {\n    opts = parseArgv(argv);\n  } catch (e) {\n    warn('json: error: %s', e.message);\n    return drainStdoutAndExit(1);\n  }\n  //warn(opts);\n  if (opts.help) {\n    printHelp();\n    return;\n  }\n  if (opts.version) {\n    if (opts.outputMode === OM_JSON) {\n      var v = {\n        version: getVersion(),\n        author: 'Trent Mick',\n        project: 'https://github.com/trentm/json'\n      };\n      console.log(JSON.stringify(v, null, opts.jsonIndent));\n    } else {\n      console.log('json ' + getVersion());\n      console.log('written by Trent Mick');\n      console.log('https://github.com/trentm/json');\n    }\n    return;\n  }\n  var lookupStrs = opts.args;\n\n  // Prepare condition and execution funcs (and vm scripts) for -c/-e.\n  var execVm = Boolean(process.env.JSON_EXEC && process.env.JSON_EXEC === 'vm');\n  var i;\n  var condFuncs = [];\n  if (!execVm) {\n    for (i = 0; i < opts.condSnippets.length; i++) {\n      condFuncs[i] = funcWithReturnFromSnippet(opts.condSnippets[i]);\n    }\n  }\n  var condScripts = [];\n  if (execVm) {\n    for (i = 0; i < opts.condSnippets.length; i++) {\n      condScripts[i] = vm.createScript(opts.condSnippets[i]);\n    }\n  }\n  var cond = Boolean(condFuncs.length + condScripts.length);\n  var exeFuncs = [];\n  if (!execVm) {\n    for (i = 0; i < opts.exeSnippets.length; i++) {\n      exeFuncs[i] = new Function(opts.exeSnippets[i]);\n    }\n  }\n  var exeScripts = [];\n  if (execVm) {\n    for (i = 0; i < opts.exeSnippets.length; i++) {\n      exeScripts[i] = vm.createScript(opts.exeSnippets[i]);\n    }\n  }\n  var exe = Boolean(exeFuncs.length + exeScripts.length);\n  try {\n    var lookups = lookupStrs.map(function (lookup) {\n      return parseLookup(lookup, opts.lookupDelim);\n    });\n  } catch (e) {\n    warn('json: error: %s', e.message);\n    return drainStdoutAndExit(1);\n  }\n  if (opts.group && opts.array && opts.outputMode !== OM_JSON) {\n    // streaming\n    var chunker = chunkEmitter(opts);\n    chunker.on('error', function (error) {\n      warn('json: error: %s', err.message);\n      return drainStdoutAndExit(1);\n    });\n    chunker.on('chunk', parseChunk);\n  } else if (opts.inPlace) {\n    assert.equal(opts.inputFiles.length, 1, 'cannot handle more than one file with -I');\n    getInput(opts, function (err, content, filename) {\n      if (err) {\n        warn('json: error: %s', err.message);\n        return drainStdoutAndExit(1);\n      }\n\n      // Take off a leading HTTP header if any and pass it through.\n      var headers = [];\n      while (true) {\n        if (content.slice(0, 5) === 'HTTP/') {\n          var index = content.indexOf('\\r\\n\\r\\n');\n          var sepLen = 4;\n          if (index == -1) {\n            index = content.indexOf('\\n\\n');\n            sepLen = 2;\n          }\n          if (index != -1) {\n            if (!opts.dropHeaders) {\n              headers.push(content.slice(0, index + sepLen));\n            }\n            var is100Continue = content.slice(0, 21) === 'HTTP/1.1 100 Continue';\n            content = content.slice(index + sepLen);\n            if (is100Continue) {\n              continue;\n            }\n          }\n        }\n        break;\n      }\n      parseChunk(content, undefined, filename, true, headers.join(''));\n    });\n  } else {\n    // not streaming\n    getInput(opts, function (err, buffer, filename) {\n      if (err) {\n        warn('json: error: %s', err.message);\n        return drainStdoutAndExit(1);\n      }\n      // Take off a leading HTTP header if any and pass it through.\n      while (true) {\n        if (buffer.slice(0, 5) === 'HTTP/') {\n          var index = buffer.indexOf('\\r\\n\\r\\n');\n          var sepLen = 4;\n          if (index == -1) {\n            index = buffer.indexOf('\\n\\n');\n            sepLen = 2;\n          }\n          if (index != -1) {\n            if (!opts.dropHeaders) {\n              emit(buffer.slice(0, index + sepLen));\n            }\n            var is100Continue = buffer.slice(0, 21) === 'HTTP/1.1 100 Continue';\n            buffer = buffer.slice(index + sepLen);\n            if (is100Continue) {\n              continue;\n            }\n          }\n        }\n        break;\n      }\n      parseChunk(buffer, null, filename, false);\n    });\n  }\n\n  /**\n   * Parse a single chunk of JSON. This may be called more than once\n   * (when streaming or when operating on multiple files).\n   *\n   * @param chunk {String} The JSON-encoded string.\n   * @param obj {Object} Optional. For some code paths while streaming `obj`\n   *    will be provided. This is an already parsed JSON object.\n   * @param filename {String} Optional. The filename from which this content\n   *    came, if relevant.\n   * @param inPlace {Boolean} Optional. If true, then output will be written\n   *    to `filename`.\n   * @param headers {String} Optional. Leading HTTP headers, if any to emit.\n   */\n  function parseChunk(chunk, obj, filename, inPlace, headers) {\n    // Expect the chunk to be JSON.\n    if (!chunk.length) {\n      return;\n    }\n    // parseInput() -> {datum: <input object>, error: <error object>}\n    var input = parseInput(chunk, obj, opts.group, opts.merge);\n    if (input.error) {\n      // Doesn't look like JSON. Just print it out and move on.\n      if (!opts.quiet) {\n        // Use JSON-js' \"json_parse\" parser to get more detail on the\n        // syntax error.\n        var details = '';\n        var normBuffer = chunk.replace(/\\r\\n|\\n|\\r/, '\\n');\n        try {\n          json_parse(normBuffer);\n          details = input.error;\n        } catch (err) {\n          // err.at has the position. Get line/column from that.\n          var at = err.at - 1; // `err.at` looks to be 1-based.\n          var lines = chunk.split('\\n');\n          var line,\n            col,\n            pos = 0;\n          for (line = 0; line < lines.length; line++) {\n            pos += lines[line].length + 1;\n            if (pos > at) {\n              col = at - (pos - lines[line].length - 1);\n              break;\n            }\n          }\n          var spaces = '';\n          for (var i = 0; i < col; i++) {\n            spaces += '.';\n          }\n          details = err.message + ' at line ' + (line + 1) + ', column ' + (col + 1) + ':\\n        ' + lines[line] + '\\n        ' + spaces + '^';\n        }\n        warn('json: error: %s is not JSON: %s', filename ? '\"' + filename + '\"' : 'input', details);\n      }\n      if (!opts.validate) {\n        emit(chunk);\n        if (chunk.length && chunk[chunk.length - 1] !== '\\n') {\n          emit('\\n');\n        }\n      }\n      return drainStdoutAndExit(1);\n    }\n    if (opts.validate) {\n      return drainStdoutAndExit(0);\n    }\n    var data = input.datum;\n\n    // Process: items (-M, --items)\n    if (opts.items) {\n      if (!Array.isArray(data)) {\n        var key;\n        var array = [];\n        for (key in data) {\n          if (data.hasOwnProperty(key)) {\n            array.push({\n              key: key,\n              value: data[key]\n            });\n          }\n        }\n        data = array;\n      }\n    }\n\n    // Process: executions (-e, -E)\n    var i, j;\n    if (!exe) {\n      /* pass */\n    } else if (opts.array || opts.array === null && Array.isArray(data)) {\n      var arrayified = false;\n      if (!Array.isArray(data)) {\n        arrayified = true;\n        data = [data];\n      }\n      for (i = 0; i < data.length; i++) {\n        var datum = data[i];\n        for (j = 0; j < exeFuncs.length; j++) {\n          exeFuncs[j].call(datum);\n        }\n        for (j = 0; j < exeScripts.length; j++) {\n          exeScripts[j].runInNewContext(datum);\n        }\n      }\n      if (arrayified) {\n        data = data[0];\n      }\n    } else {\n      for (j = 0; j < exeFuncs.length; j++) {\n        exeFuncs[j].call(data);\n      }\n      for (j = 0; j < exeScripts.length; j++) {\n        exeScripts[j].runInNewContext(data);\n      }\n    }\n\n    // Process: conditionals (-c)\n    if (!cond) {\n      /* pass */\n    } else if (opts.array || opts.array === null && Array.isArray(data)) {\n      var arrayified = false;\n      if (!Array.isArray(data)) {\n        arrayified = true;\n        data = [data];\n      }\n      var filtered = [];\n      for (i = 0; i < data.length; i++) {\n        var datum = data[i];\n        var datumCopy = objCopy(datum);\n        var keep = true;\n        // TODO(perf): Perhaps drop the 'datumCopy'? \"this is a gun\"\n        for (j = 0; j < condFuncs.length; j++) {\n          if (!condFuncs[j].call(datumCopy)) {\n            keep = false;\n            break;\n          }\n        }\n        if (keep) {\n          for (j = 0; j < condScripts.length; j++) {\n            if (!condScripts[j].runInNewContext(datumCopy)) {\n              keep = false;\n              break;\n            }\n          }\n          if (keep) {\n            filtered.push(datum);\n          }\n        }\n      }\n      if (arrayified) {\n        data = filtered.length ? filtered[0] : [];\n      } else {\n        data = filtered;\n      }\n    } else {\n      var keep = true;\n      var dataCopy = objCopy(data);\n      for (j = 0; j < condFuncs.length; j++) {\n        // TODO(perf): Perhaps drop the 'dataCopy'? \"this is a gun\"\n        if (!condFuncs[j].call(dataCopy)) {\n          keep = false;\n          break;\n        }\n      }\n      if (keep) {\n        for (j = 0; j < condScripts.length; j++) {\n          if (!condScripts[j].runInNewContext(dataCopy)) {\n            keep = false;\n            break;\n          }\n        }\n      }\n      if (!keep) {\n        data = undefined;\n      }\n    }\n\n    // Process: lookups\n    var lookupsAreIndeces = false;\n    if (lookups.length) {\n      if (opts.array) {\n        if (!Array.isArray(data)) data = [data];\n        var table = [];\n        for (j = 0; j < data.length; j++) {\n          var datum = data[j];\n          var row = {};\n          for (i = 0; i < lookups.length; i++) {\n            var lookup = lookups[i];\n            var value = lookupDatum(datum, lookup);\n            if (value !== undefined) {\n              row[lookup.join('.')] = value;\n            }\n          }\n          table.push(row);\n        }\n        data = table;\n      } else {\n        // Special case handling: Note if the 'lookups' are indeces into\n        // an array. This may be used below to change the output\n        // representation.\n        if (Array.isArray(data)) {\n          lookupsAreIndeces = true;\n          for (i = 0; i < lookups.length; i++) {\n            if (lookups[i].length !== 1 || isNaN(Number(lookups[i]))) {\n              lookupsAreIndeces = false;\n              break;\n            }\n          }\n        }\n        var row = {};\n        for (i = 0; i < lookups.length; i++) {\n          var lookup = lookups[i];\n          var value = lookupDatum(data, lookup);\n          if (value !== undefined) {\n            row[lookup.join('.')] = value;\n          }\n        }\n        data = row;\n      }\n    }\n\n    // --keys\n    if (opts.outputKeys) {\n      var data = Object.keys(data);\n    }\n\n    // Output\n    var datasets = [];\n    if (opts.outputMode === OM_JSON) {\n      if (lookups.length === 1 && !opts.array) {\n        /**\n         * Special case: For JSON output of a *single* lookup, *don't*\n         * use the full table structure, else there is no way to get\n         * string quoting for a single value:\n         *      $ echo '{\"a\": [], \"b\": \"[]\"}' | json -j a\n         *      []\n         *      $ echo '{\"a\": [], \"b\": \"[]\"}' | json -j b\n         *      '[]'\n         * See <https://github.com/trentm/json/issues/35> for why.\n         */\n        data = data[lookups[0].join('.')];\n      } else if (lookupsAreIndeces) {\n        /**\n         * Special case: Lookups that are all indeces into an input\n         * array are more likely to be wanted as an array of selected\n         * items rather than a 'JSON table' thing that we use otherwise.\n         */\n        var flattened = [];\n        for (i = 0; i < lookups.length; i++) {\n          var lookupStr = lookups[i].join('.');\n          if (data.hasOwnProperty(lookupStr)) {\n            flattened.push(data[lookupStr]);\n          }\n        }\n        data = flattened;\n      }\n      // If JSON output mode, then always just output full set of data to\n      // ensure valid JSON output.\n      datasets.push([data, '\\n', false]);\n    } else if (lookups.length) {\n      if (opts.array) {\n        // Output `data` as a 'table' of lookup results.\n        for (j = 0; j < data.length; j++) {\n          var row = data[j];\n          for (i = 0; i < lookups.length - 1; i++) {\n            datasets.push([row[lookups[i].join('.')], opts.delim, true]);\n          }\n          datasets.push([row[lookups[i].join('.')], '\\n', true]);\n        }\n      } else {\n        for (i = 0; i < lookups.length; i++) {\n          datasets.push([data[lookups[i].join('.')], '\\n', false]);\n        }\n      }\n    } else if (opts.array) {\n      if (!Array.isArray(data)) data = [data];\n      for (j = 0; j < data.length; j++) {\n        datasets.push([data[j], '\\n', false]);\n      }\n    } else {\n      // Output `data` as is.\n      datasets.push([data, '\\n', false]);\n    }\n    printDatasets(datasets, inPlace ? filename : undefined, headers, opts);\n  }\n}\nif (require.main === module) {\n  // HACK guard for <https://github.com/trentm/json/issues/24>.\n  // We override the `process.stdout.end` guard that core node.js puts in\n  // place. The real fix is that `.end()` shouldn't be called on stdout\n  // in node core. Hopefully node v0.6.9 will fix that. Only guard\n  // for v0.6.0..v0.6.8.\n  var nodeVer = process.versions.node.split('.').map(Number);\n  if ([0, 6, 0] <= nodeVer && nodeVer <= [0, 6, 8]) {\n    var stdout = process.stdout;\n    stdout.end = stdout.destroy = stdout.destroySoon = function () {\n      /* pass */\n    };\n  }\n  main(process.argv);\n}","map":{"version":3,"names":["VERSION","p","console","warn","util","require","assert","path","vm","fs","EventEmitter","exports","main","getVersion","parseLookup","lookupDatum","printDatum","OM_JSONY","OM_JSON","OM_INSPECT","OM_COMPACT","OM_FROM_NAME","objCopy","obj","copy","Array","isArray","slice","Object","keys","forEach","k","format","formatRegExp","f","i","objects","arguments","length","push","inspect","join","args","len","str","String","replace","x","Number","JSON","stringify","_parseString","s","quoted","parse","json_parse","at","ch","escapee","b","n","r","t","text","error","m","name","message","next","c","charAt","number","string","isFinite","hex","uffff","parseInt","fromCharCode","white","word","value","array","object","key","hasOwnProperty","call","source","reviver","result","walk","holder","v","prototype","undefined","printHelp","w","log","parseArgv","argv","parsed","help","quiet","dropHeaders","exeSnippets","condSnippets","outputMode","jsonIndent","delim","lookupDelim","items","outputKeys","group","merge","inputFiles","validate","inPlace","newArgs","optTakesArg","concat","splitOpts","split","j","optArg","endOfOptions","arg","shift","version","Error","idx","lastIndexOf","indent","test","outputDelim","parseErr","chunkEmitter","opts","emitter","streaming","chunks","leftover","finishedHeaders","stripHeaders","index","indexOf","sepLen","emit","is100Continue","emitChunks","block","splitter","leftTrimmedBlock","trimLeft","bits","trimmed","e","addDataListener","stream","on","chunk","addErrorListener","file","err","addEndListener","nextFile","createReadStream","encoding","first","stdin","process","openStdin","setEncoding","getInput","callback","content","readFileSync","isInteger","search","lookup","debug","bit","states","escaped","SUPPORTED_ESCAPES","nextCh","escapedCh","pop","VALID_QUOTES","sQuote","eQuote","negIntPat","parseInput","buffer","datum","newBuffer","pat","trim","e2","objs","merged","deepExtend","a","toString","d","printDatasets","datasets","filename","headers","isTTY","stdout","write","tmpPath","resolve","dirname","basename","pid","Date","now","stats","statSync","createWriteStream","mode","bind","dataset","output","stringifyDatum","sep","end","renameSync","Infinity","alwaysPrintSep","stdoutFlushed","drainingStdout","code","drainStdoutAndExit","exit","funcWithReturnFromSnippet","js","substring","Function","author","project","lookupStrs","execVm","Boolean","env","JSON_EXEC","condFuncs","condScripts","createScript","cond","exeFuncs","exeScripts","exe","lookups","map","chunker","parseChunk","equal","input","details","normBuffer","lines","line","col","pos","spaces","data","arrayified","runInNewContext","filtered","datumCopy","keep","dataCopy","lookupsAreIndeces","table","row","isNaN","flattened","lookupStr","module","nodeVer","versions","node","destroy","destroySoon"],"sources":["/Users/guchiyam/Desktop/CPSC/cpsc-362/github/node_modules/json/lib/json.js"],"sourcesContent":["#!/usr/bin/env node\n/**\n * Copyright 2021 Trent Mick.\n * Copyright 2020 Joyent Inc.\n *\n * json -- JSON love for your command line.\n *\n * See <https://github.com/trentm/json> and <https://trentm.com/json/>\n */\n\nvar VERSION = '11.0.0';\n\nvar p = console.warn;\nvar util = require('util');\nvar assert = require('assert');\nvar path = require('path');\nvar vm = require('vm');\nvar fs = require('fs');\nvar warn = console.warn;\nvar EventEmitter = require('events').EventEmitter;\n\n\n\n//--- exports for module usage\n\nexports.main = main;\nexports.getVersion = getVersion;\nexports.parseLookup = parseLookup;\n\n// As an exported API, these are still experimental:\nexports.lookupDatum = lookupDatum;\nexports.printDatum = printDatum; // DEPRECATED\n\n\n\n//---- globals and constants\n\n// Output modes.\nvar OM_JSONY = 1;\nvar OM_JSON = 2;\nvar OM_INSPECT = 3;\nvar OM_COMPACT = 4;\nvar OM_FROM_NAME = {\n    'jsony': OM_JSONY,\n    'json': OM_JSON,\n    'inspect': OM_INSPECT,\n    'compact': OM_COMPACT\n};\n\n\n\n//---- support functions\n\nfunction getVersion() {\n    return VERSION;\n}\n\n/**\n * Return a *shallow* copy of the given object.\n *\n * Only support objects that you get out of JSON, i.e. no functions.\n */\nfunction objCopy(obj) {\n    var copy;\n    if (Array.isArray(obj)) {\n        copy = obj.slice();\n    } else if (typeof (obj) === 'object') {\n        copy = {};\n        Object.keys(obj).forEach(function (k) {\n            copy[k] = obj[k];\n        });\n    } else {\n        copy = obj; // immutable type\n    }\n    return copy;\n}\n\nif (util.format) {\n    format = util.format;\n} else {\n    // From <https://github.com/joyent/node/blob/master/lib/util.js#L22>:\n    var formatRegExp = /%[sdj%]/g;\n\n    function format(f) {\n        var i;\n        if (typeof (f) !== 'string') {\n            var objects = [];\n            for (i = 0; i < arguments.length; i++) {\n                objects.push(util.inspect(arguments[i]));\n            }\n            return objects.join(' ');\n        }\n        i = 1;\n        var args = arguments;\n        var len = args.length;\n        var str = String(f).replace(formatRegExp, function (x) {\n            if (i >= len)\n              return x;\n            switch (x) {\n            case '%s':\n                return String(args[i++]);\n            case '%d':\n                return Number(args[i++]);\n            case '%j':\n                return JSON.stringify(args[i++]);\n            case '%%':\n                return '%';\n            default:\n                return x;\n            }\n        });\n        for (var x = args[i]; i < len; x = args[++i]) {\n            if (x === null || typeof (x) !== 'object') {\n                str += ' ' + x;\n            } else {\n                str += ' ' + util.inspect(x);\n            }\n        }\n        return str;\n    }\n}\n\n/**\n * Parse the given string into a JS string. Basically: handle escapes.\n * Note that this only handles JSON escapes, which are a subset of all\n * JavaScript-supported string escapes.\n */\nfunction _parseString(s) {\n    /* JSSTYLED */\n    var quoted = '\"' + s.replace(/\\\\\"/g, '\"').replace(/\"/g, '\\\\\"') + '\"';\n    return JSON.parse(quoted);\n}\n\n// json_parse.js (<https://github.com/douglascrockford/JSON-js>)\n/* BEGIN JSSTYLED */\n// START json_parse\nvar json_parse=function(){\"use strict\";var at,ch,escapee={'\"':'\"',\"\\\\\":\"\\\\\",\"/\":\"/\",b:\"\\b\",f:\"\\f\",n:\"\\n\",r:\"\\r\",t:\"\\t\"},text,error=function(m){throw{name:\"SyntaxError\",message:m,at:at,text:text}},next=function(c){if(c&&c!==ch){error(\"Expected '\"+c+\"' instead of '\"+ch+\"'\")}ch=text.charAt(at);at+=1;return ch},number=function(){var number,string=\"\";if(ch===\"-\"){string=\"-\";next(\"-\")}while(ch>=\"0\"&&ch<=\"9\"){string+=ch;next()}if(ch===\".\"){string+=\".\";while(next()&&ch>=\"0\"&&ch<=\"9\"){string+=ch}}if(ch===\"e\"||ch===\"E\"){string+=ch;next();if(ch===\"-\"||ch===\"+\"){string+=ch;next()}while(ch>=\"0\"&&ch<=\"9\"){string+=ch;next()}}number=+string;if(!isFinite(number)){error(\"Bad number\")}else{return number}},string=function(){var hex,i,string=\"\",uffff;if(ch==='\"'){while(next()){if(ch==='\"'){next();return string}else if(ch===\"\\\\\"){next();if(ch===\"u\"){uffff=0;for(i=0;i<4;i+=1){hex=parseInt(next(),16);if(!isFinite(hex)){break}uffff=uffff*16+hex}string+=String.fromCharCode(uffff)}else if(typeof escapee[ch]===\"string\"){string+=escapee[ch]}else{break}}else{string+=ch}}}error(\"Bad string\")},white=function(){while(ch&&ch<=\" \"){next()}},word=function(){switch(ch){case\"t\":next(\"t\");next(\"r\");next(\"u\");next(\"e\");return true;case\"f\":next(\"f\");next(\"a\");next(\"l\");next(\"s\");next(\"e\");return false;case\"n\":next(\"n\");next(\"u\");next(\"l\");next(\"l\");return null}error(\"Unexpected '\"+ch+\"'\")},value,array=function(){var array=[];if(ch===\"[\"){next(\"[\");white();if(ch===\"]\"){next(\"]\");return array}while(ch){array.push(value());white();if(ch===\"]\"){next(\"]\");return array}next(\",\");white()}}error(\"Bad array\")},object=function(){var key,object={};if(ch===\"{\"){next(\"{\");white();if(ch===\"}\"){next(\"}\");return object}while(ch){key=string();white();next(\":\");if(Object.hasOwnProperty.call(object,key)){error('Duplicate key \"'+key+'\"')}object[key]=value();white();if(ch===\"}\"){next(\"}\");return object}next(\",\");white()}}error(\"Bad object\")};value=function(){white();switch(ch){case\"{\":return object();case\"[\":return array();case'\"':return string();case\"-\":return number();default:return ch>=\"0\"&&ch<=\"9\"?number():word()}};return function(source,reviver){var result;text=source;at=0;ch=\" \";result=value();white();if(ch){error(\"Syntax error\")}return typeof reviver===\"function\"?function walk(holder,key){var k,v,value=holder[key];if(value&&typeof value===\"object\"){for(k in value){if(Object.prototype.hasOwnProperty.call(value,k)){v=walk(value,k);if(v!==undefined){value[k]=v}else{delete value[k]}}}}return reviver.call(holder,key,value)}({\"\":result},\"\"):result}}();\n\n// END json_parse\n/* END JSSTYLED */\n\nfunction printHelp() {\n    /* BEGIN JSSTYLED */\n    var w = console.log;\n    w('Usage:');\n    w('  <something generating JSON on stdout> | json [OPTIONS] [LOOKUPS...]');\n    w('  json -f FILE [OPTIONS] [LOOKUPS...]');\n    w('');\n    w('Pipe in your JSON for pretty-printing, JSON validation, filtering, ');\n    w('and modification. Supply one or more `LOOKUPS` to extract a ');\n    w('subset of the JSON. HTTP header blocks are skipped by default.');\n    w('Roughly in order of processing, features are:');\n    w('');\n    w('Grouping:');\n    w('  Use \"-g\" or \"--group\" to group adjacent objects, separated by');\n    w('  by no space or a by a newline, or adjacent arrays, separate by');\n    w('  by a newline. This can be helpful for, e.g.: ');\n    w('     $ cat *.json | json -g ... ');\n    w('  and similar.');\n    w('');\n    w('Execution:');\n    w('  Use the \"-e CODE\" option to execute JavaScript code on the input JSON.');\n    w('     $ echo \\'{\"name\":\"trent\",\"age\":38}\\' | json -e \\'this.age++\\'');\n    w('     {');\n    w('       \"name\": \"trent\",');\n    w('       \"age\": 39');\n    w('     }');\n    w('  If input is an array, this will automatically process each');\n    w('  item separately.');\n    w('');\n    w('Conditional filtering:');\n    w('  Use the \"-c CODE\" option to filter the input JSON.');\n    w('     $ echo \\'[{\"age\":38},{\"age\":4}]\\' | json -c \\'this.age>21\\'');\n    w('     [{\\'age\\':38}]');\n    w('  If input is an array, this will automatically process each');\n    w('  item separately. Note: \"CODE\" is JavaScript code.');\n    w('');\n    w('Lookups:');\n    w('  Use lookup arguments to extract particular values:');\n    w('     $ echo \\'{\"name\":\"trent\",\"age\":38}\\' | json name');\n    w('     trent');\n    w('');\n    w('  Use \"-a\" for *array processing* of lookups and *tabular output*:');\n    w('     $ echo \\'{\"name\":\"trent\",\"age\":38}\\' | json name age');\n    w('     trent');\n    w('     38');\n    w('     $ echo \\'[{\"name\":\"trent\",\"age\":38},');\n    w('               {\"name\":\"ewan\",\"age\":4}]\\' | json -a name age');\n    w('     trent 38');\n    w('     ewan 4');\n    w('');\n    w('In-place editing:');\n    w('  Use \"-I, --in-place\" to edit a file in place:');\n    w('     $ json -I -f config.json  # reformat');\n    w('     $ json -I -f config.json -c \\'this.logLevel=\"debug\"\\' # add field');\n    w('');\n    w('Pretty-printing:');\n    w('  Output is \"jsony\" by default: 2-space indented JSON, except a');\n    w('  single string value is printed without quotes.');\n    w('     $ echo \\'{\"name\": \"trent\", \"age\": 38}\\' | json');\n    w('     {');\n    w('       \"name\": \"trent\",');\n    w('       \"age\": 38');\n    w('     }');\n    w('     $ echo \\'{\"name\": \"trent\", \"age\": 38}\\' | json name');\n    w('     trent');\n    w('');\n    w(\"  Use '-j' or '-o json' for explicit JSON, '-o json-N' for N-space indent:\");\n    w('     $ echo \\'{\"name\": \"trent\", \"age\": 38}\\' | json -o json-0');\n    w('     {\"name\":\"trent\",\"age\":38}');\n    w('');\n    w('Options:');\n    w('  -h, --help    Print this help info and exit.');\n    w('  --version     Print version of this command and exit.');\n    w('  -q, --quiet   Don\\'t warn if input isn\\'t valid JSON.');\n    w('');\n    w('  -f FILE       Path to a file to process. If not given, then');\n    w('                stdin is used.');\n    w('  -I, --in-place  In-place edit of the file given with \"-f\".');\n    w('                Lookups are not allow with in-place editing');\n    w('                because it makes it too easy to lose content.');\n    w('');\n    w('  -H            Drop any HTTP header block (as from `curl -i ...`).');\n    w('  -g, --group   Group adjacent objects or arrays into an array.');\n    w('  --merge       Merge adjacent objects into one. Keys in last ');\n    w('                object win.');\n    w('  --deep-merge  Same as \"--merge\", but will recurse into objects ');\n    w('                under the same key in both.')\n    w('  -a, --array   Process input as an array of separate inputs');\n    w('                and output in tabular form.');\n    w('  -A            Process input as a single object, i.e. stop');\n    w('                \"-e\" and \"-c\" automatically processing each');\n    w('                item of an input array.');\n    w('  -d DELIM      Delimiter char for tabular output (default is \" \").');\n    w('  -D DELIM      Delimiter char between lookups (default is \".\"). E.g.:');\n    w('                    $ echo \\'{\"a.b\": {\"b\": 1}}\\' | json -D / a.b/b');\n    w('');\n    w('  -M, --items   Itemize an object into an array of ');\n    w('                    {\"key\": <key>, \"value\": <value>}');\n    w('                objects for easier processing.');\n    w('');\n    w('  -e CODE       Execute the given JavaScript code on the input. If input');\n    w('                is an array, then each item of the array is processed');\n    w('                separately (use \"-A\" to override).');\n    w('  -c CODE       Filter the input with JavaScript `CODE`. If `CODE`');\n    w('                returns false-y, then the item is filtered out. If');\n    w('                input is an array, then each item of the array is ');\n    w('                processed separately (use \"-A\" to override).');\n    w('');\n    w('  -k, --keys    Output the input object\\'s keys.');\n    w('  -n, --validate  Just validate the input (no processing or output).');\n    w('                Use with \"-q\" for silent validation (exit status).');\n    w('');\n    w('  -o, --output MODE');\n    w('                Specify an output mode. One of:');\n    w('                    jsony (default): JSON with string quotes elided');\n    w('                    json: JSON output, 2-space indent');\n    w('                    json-N: JSON output, N-space indent, e.g. \"json-4\"');\n    w('                    inspect: node.js `util.inspect` output');\n    w('  -i            Shortcut for `-o inspect`');\n    w('  -j            Shortcut for `-o json`');\n    w('  -0, -2, -4    Set indentation to the given value w/o setting MODE.');\n    w('                    -0   =>  -o jsony-0');\n    w('                    -4   =>  -o jsony-4');\n    w('                    -j0  =>  -o json-0');\n    w('');\n    w('See <http://trentm.com/json> for more docs and ');\n    w('<https://github.com/trentm/json> for project details.');\n    /* END JSSTYLED */\n}\n\n\n/**\n * Parse the command-line options and arguments into an object.\n *\n *    {\n *      'args': [...]       // arguments\n *      'help': true,       // true if '-h' option given\n *       // etc.\n *    }\n *\n * @return {Object} The parsed options. `.args` is the argument list.\n * @throws {Error} If there is an error parsing argv.\n */\nfunction parseArgv(argv) {\n    var parsed = {\n        args: [],\n        help: false,\n        quiet: false,\n        dropHeaders: false,\n        exeSnippets: [],\n        condSnippets: [],\n        outputMode: OM_JSONY,\n        jsonIndent: 2,\n        array: null,\n        delim: ' ',\n        lookupDelim: '.',\n        items: false,\n        outputKeys: false,\n        group: false,\n        merge: null, // --merge -> 'shallow', --deep-merge -> 'deep'\n        inputFiles: [],\n        validate: false,\n        inPlace: false\n    };\n\n    // Turn '-iH' into '-i -H', except for argument-accepting options.\n    var args = argv.slice(2); // drop ['node', 'scriptname']\n    var newArgs = [];\n    var optTakesArg = {\n        'd': true,\n        'o': true,\n        'D': true\n    };\n    for (var i = 0; i < args.length; i++) {\n        if (args[i] === '--') {\n            newArgs = newArgs.concat(args.slice(i));\n            break;\n        }\n        if (args[i].charAt(0) === '-' && args[i].charAt(1) !== '-' &&\n            args[i].length > 2)\n        {\n            var splitOpts = args[i].slice(1).split('');\n            for (var j = 0; j < splitOpts.length; j++) {\n                newArgs.push('-' + splitOpts[j])\n                if (optTakesArg[splitOpts[j]]) {\n                    var optArg = splitOpts.slice(j + 1).join('');\n                    if (optArg.length) {\n                        newArgs.push(optArg);\n                    }\n                    break;\n                }\n            }\n        } else {\n            newArgs.push(args[i]);\n        }\n    }\n    args = newArgs;\n\n    endOfOptions = false;\n    while (args.length > 0) {\n        var arg = args.shift();\n        if (endOfOptions) {\n            parsed.args.push(arg);\n            break;\n        }\n        switch (arg) {\n        case '--':\n            endOfOptions = true;\n            break;\n        case '-h': // display help and exit\n        case '--help':\n            parsed.help = true;\n            break;\n        case '--version':\n            parsed.version = true;\n            break;\n        case '-q':\n        case '--quiet':\n            parsed.quiet = true;\n            break;\n        case '-H': // drop any headers\n            parsed.dropHeaders = true;\n            break;\n        case '-o':\n        case '--output':\n            var name = args.shift();\n            if (!name) {\n                throw new Error('no argument given for \"-o|--output\" option');\n            }\n            var idx = name.lastIndexOf('-');\n            if (idx !== -1) {\n                var indent = name.slice(idx + 1);\n                if (/^\\d+$/.test(indent)) {\n                    parsed.jsonIndent = Number(indent);\n                    name = name.slice(0, idx);\n                } else if (indent === 'tab') {\n                    parsed.jsonIndent = '\\t';\n                    name = name.slice(0, idx);\n                }\n            }\n            parsed.outputMode = OM_FROM_NAME[name];\n            if (parsed.outputMode === undefined) {\n                throw new Error('unknown output mode: \"' + name + '\"');\n            }\n            break;\n        case '-0':\n            parsed.jsonIndent = 0;\n            break;\n        case '-2':\n            parsed.jsonIndent = 2;\n            break;\n        case '-4':\n            parsed.jsonIndent = 4;\n            break;\n        case '-I':\n        case '--in-place':\n            parsed.inPlace = true;\n            break;\n        case '-i': // output with util.inspect\n            parsed.outputMode = OM_INSPECT;\n            break;\n        case '-j': // output with JSON.stringify\n            parsed.outputMode = OM_JSON;\n            break;\n        case '-a':\n        case '--array':\n            parsed.array = true;\n            break;\n        case '-A':\n            parsed.array = false;\n            break;\n        case '-d':\n            var outputDelim = args.shift()\n            try {\n                parsed.delim = _parseString(outputDelim);\n            } catch (parseErr) {\n                throw new Error(format('could not parse delim \"%s\": %s',\n                    outputDelim, parseErr.message));\n            }\n            break;\n        case '-D':\n            parsed.lookupDelim = args.shift();\n            if (parsed.lookupDelim.length !== 1) {\n                throw new Error(format(\n                    'invalid lookup delim \"%s\" (must be a single char)',\n                    parsed.lookupDelim));\n            }\n            break;\n        case '-e':\n        case '-E':  // DEPRECATED in v9\n            parsed.exeSnippets.push(args.shift());\n            break;\n        case '-c':\n        case '-C':  // DEPRECATED in v9\n            parsed.condSnippets.push(args.shift());\n            break;\n        case '-M':\n        case '--items':\n            parsed.items = true;\n            break;\n        case '-k':\n        case '--keys':\n            parsed.outputKeys = true;\n            break;\n        case '-g':\n        case '--group':\n            parsed.group = true;\n            break;\n        case '--merge':\n            parsed.merge = 'shallow';\n            break;\n        case '--deep-merge':\n            parsed.merge = 'deep';\n            break;\n        case '-f':\n            parsed.inputFiles.push(args.shift());\n            break;\n        case '-n':\n        case '--validate':\n            parsed.validate = true;\n            break;\n        default: // arguments\n            if (!endOfOptions && arg.length > 0 && arg[0] === '-') {\n                throw new Error('unknown option \"' + arg + '\"');\n            }\n            parsed.args.push(arg);\n            break;\n        }\n    }\n\n    if (parsed.group && parsed.merge) {\n        throw new Error('cannot use -g|--group and --merge options together');\n    }\n    if (parsed.outputKeys && parsed.args.length > 0) {\n        throw new Error(\n            'cannot use -k|--keys option and lookup arguments together');\n    }\n    if (parsed.inPlace && parsed.inputFiles.length !== 1) {\n        throw new Error('must specify exactly one file with \"-f FILE\" to ' +\n            'use -I/--in-place');\n    }\n    if (parsed.inPlace && parsed.args.length > 0) {\n        throw new Error('lookups cannot be specified with in-place editing ' +\n            '(-I/--in-place), too easy to lose content');\n    }\n\n    return parsed;\n}\n\n\n\n/**\n * Streams chunks from given file paths or stdin.\n *\n * @param opts {Object} Parsed options.\n * @returns {Object} An emitter that emits 'chunk', 'error', and 'end'.\n *    - `emit('chunk', chunk, [obj])` where chunk is a complete block of JSON\n *       ready to parse. If `obj` is provided, it is the already parsed\n *       JSON.\n *    - `emit('error', error)` when an underlying stream emits an error\n *    - `emit('end')` when all streams are done\n */\nfunction chunkEmitter(opts) {\n    var emitter = new EventEmitter();\n    var streaming = true;\n    var chunks = [];\n    var leftover = '';\n    var finishedHeaders = false;\n\n    function stripHeaders(s) {\n        // Take off a leading HTTP header if any and pass it through.\n        while (true) {\n            if (s.slice(0, 5) === 'HTTP/') {\n                var index = s.indexOf('\\r\\n\\r\\n');\n                var sepLen = 4;\n                if (index == -1) {\n                    index = s.indexOf('\\n\\n');\n                    sepLen = 2;\n                }\n                if (index != -1) {\n                    if (!opts.dropHeaders) {\n                        emit(s.slice(0, index + sepLen));\n                    }\n                    var is100Continue = (\n                        s.slice(0, 21) === 'HTTP/1.1 100 Continue');\n                    s = s.slice(index + sepLen);\n                    if (is100Continue) {\n                        continue;\n                    }\n                    finishedHeaders = true;\n                }\n            } else {\n                finishedHeaders = true;\n            }\n            break;\n        }\n        //console.warn('stripHeaders done, finishedHeaders=%s', finishedHeaders)\n        return s;\n    }\n\n    function emitChunks(block, emitter) {\n        //console.warn('emitChunks start: block=\"%s\"', block)\n        /* JSSTYLED */\n        var splitter = /(})(\\s*\\n\\s*)?({\\s*\")/;\n        var leftTrimmedBlock = block.trimLeft();\n        if (leftTrimmedBlock && leftTrimmedBlock[0] !== '{') {\n            // Currently only support streaming consecutive *objects*.\n            streaming = false;\n            chunks.push(block);\n            return '';\n        }\n        /**\n         * Example:\n         * > '{\"a\":\"b\"}\\n{\"a\":\"b\"}\\n{\"a\":\"b\"}'.split(/(})(\\s*\\n\\s*)?({\\s*\")/)\n         * [ '{\"a\":\"b\"',\n         *   '}',\n         *   '\\n',\n         *   '{\"',\n         *   'a\":\"b\"',\n         *   '}',\n         *   '\\n',\n         *   '{\"',\n         *   'a\":\"b\"}' ]\n         */\n        var bits = block.split(splitter);\n        //console.warn('emitChunks: bits (length %d): %j', bits.length, bits);\n        if (bits.length === 1) {\n            /*\n             * An unwanted side-effect of using a regex to find\n             * newline-separated objects *with a regex*, is that we are looking\n             * for the end of one object leading into the start of a another.\n             * That means that we can end up buffering a complete object until\n             * a subsequent one comes in. If the input stream has large delays\n             * between objects, then this is unwanted buffering.\n             *\n             * One solution would be full stream parsing of objects a la\n             * <https://github.com/creationix/jsonparse>. This would nicely\n             * also remove the artibrary requirement that the input stream be\n             * newline separated. jsonparse apparently has some issues tho, so\n             * I don't want to use it right now. It also isn't *small* so not\n             * sure I want to inline it (`json` doesn't have external deps).\n             *\n             * An alternative: The block we have so far one of:\n             * 1. some JSON that we don't support grouping (e.g. a stream of\n             *    non-objects),\n             * 2. a JSON object fragment, or\n             * 3. a complete JSON object (with a possible trailing '{')\n             *\n             * If #3, then we can just emit this as a chunk right now.\n             *\n             * TODO(PERF): Try out avoiding the first more complete regex split\n             * for a presumed common case of single-line newline-separated JSON\n             * objects (e.g. a bunyan log).\n             */\n            // An object must end with '}'. This is an early out to avoid\n            // `JSON.parse` which I'm *presuming* is slower.\n            var trimmed = block.split(/\\s*\\r?\\n/)[0];\n            if (trimmed[trimmed.length - 1] === '}') {\n                var obj;\n                try {\n                    obj = JSON.parse(block);\n                } catch (e) {\n                    /* pass through */\n                }\n                if (obj !== undefined) {\n                    // Emit the parsed `obj` to avoid re-parsing it later.\n                    emitter.emit('chunk', block, obj);\n                    block = '';\n                }\n            }\n            return block;\n        } else {\n            var n = bits.length - 2;\n            var s;\n            s = bits[0] + bits[1];\n            emitter.emit('chunk', s, JSON.parse(s));\n            for (var i = 3; i < n; i += 4) {\n                s = bits[i] + bits[i + 1] + bits[i + 2];\n                emitter.emit('chunk', s, JSON.parse(s));\n            }\n            return bits[n] + bits[n + 1];\n        }\n    }\n\n    function addDataListener(stream) {\n        stream.on('data', function (chunk) {\n            var s = leftover + chunk;\n            if (!finishedHeaders) {\n                s = stripHeaders(s);\n            }\n            if (!finishedHeaders) {\n                leftover = s;\n            } else {\n                if (!streaming) {\n                    chunks.push(chunk);\n                    return;\n                }\n                if (chunk.lastIndexOf('\\n') >= 0) {\n                    leftover = emitChunks(s, emitter);\n                } else {\n                    leftover = s;\n                }\n            }\n        });\n    }\n\n    if (opts.inputFiles.length > 0) {\n        // Stream each file in order.\n        var i = 0;\n\n        function addErrorListener(file) {\n            file.on('error', function (err) {\n                emitter.emit(\n                    'error',\n                    format('could not read \"%s\": %s', opts.inputFiles[i], e)\n                );\n            });\n        }\n\n        function addEndListener(file) {\n            file.on('end', function () {\n                if (i < opts.inputFiles.length) {\n                    var next = opts.inputFiles[i++];\n                    var nextFile = fs.createReadStream(next,\n                        {encoding: 'utf8'});\n                    addErrorListener(nextFile);\n                    addEndListener(nextFile);\n                    addDataListener(nextFile);\n                } else {\n                    if (!streaming) {\n                        emitter.emit('chunk', chunks.join(''));\n                    } else if (leftover) {\n                        leftover = emitChunks(leftover, emitter);\n                        emitter.emit('chunk', leftover);\n                    }\n                    emitter.emit('end');\n                }\n            });\n        }\n        var first = fs.createReadStream(opts.inputFiles[i++],\n            {encoding: 'utf8'});\n        addErrorListener(first);\n        addEndListener(first);\n        addDataListener(first);\n    } else {\n        // Streaming from stdin.\n        var stdin = process.openStdin();\n        stdin.setEncoding('utf8');\n        addDataListener(stdin);\n        stdin.on('end', function () {\n            if (!streaming) {\n                emitter.emit('chunk', chunks.join(''));\n            } else if (leftover) {\n                leftover = emitChunks(leftover, emitter);\n                emitter.emit('chunk', leftover);\n            }\n            emitter.emit('end');\n        });\n    }\n    return emitter;\n}\n\n/**\n * Get input from either given file paths or stdin. If `opts.inPlace` then\n * this calls the callback once for each `opts.inputFiles`.\n *\n * @param opts {Object} Parsed options.\n * @param callback {Function} `function (err, content, filename)` where err\n *    is an error string if there was a problem, `content` is the read\n *    content and `filename` is the associated file name from which content\n *    was loaded if applicable.\n */\nfunction getInput(opts, callback) {\n    if (opts.inputFiles.length === 0) {\n        // Read from stdin.\n        var chunks = [];\n\n        var stdin = process.openStdin();\n        stdin.setEncoding('utf8');\n        stdin.on('data', function (chunk) {\n            chunks.push(chunk);\n        });\n\n        stdin.on('end', function () {\n            callback(null, chunks.join(''));\n        });\n    } else if (opts.inPlace) {\n        for (var i = 0; i < opts.inputFiles.length; i++) {\n            var file = opts.inputFiles[i];\n            var content;\n            try {\n                content = fs.readFileSync(file, 'utf8');\n            } catch (e) {\n                callback(e, null, file);\n            }\n            if (content) {\n                callback(null, content, file);\n            }\n        }\n    } else {\n        // Read input files.\n        var i = 0;\n        var chunks = [];\n        try {\n            for (; i < opts.inputFiles.length; i++) {\n                chunks.push(fs.readFileSync(opts.inputFiles[i], 'utf8'));\n            }\n        } catch (e) {\n            return callback(\n                format('could not read \"%s\": %s', opts.inputFiles[i], e));\n        }\n        callback(null, chunks.join(''),\n            (opts.inputFiles.length === 1 ? opts.inputFiles[0] : undefined));\n    }\n}\n\n\nfunction isInteger(s) {\n    return (s.search(/^-?[0-9]+$/) == 0);\n}\n\n\n/**\n * Parse a lookup string into a list of lookup bits. E.g.:\n *\n *    'a.b.c' -> [\"a\",\"b\",\"c\"]\n *    'b[\"a\"]' -> [\"b\",\"a\"]\n *\n * Note: v10 made a backward incompatible change here that limits the supported\n * *bracketed* lookups. A bracketed section of a lookup must be of one of the\n * following forms:\n *      [\"...\"]\n *      ['...']\n *      [`...`]\n * The quoted string is not evaluated, other than supporting a subset of JS\n * string escapes (e.g. \\', \\\", \\n; but not unicode char escapes).\n * See the long block comment below in this function for details.\n *\n * Optionally receives an alternative lookup delimiter (other than '.')\n */\nfunction parseLookup(lookup, lookupDelim) {\n    var debug = function () {};\n    // var debug = console.warn;\n\n    var bits = [];\n    debug('\\n*** ' + lookup + ' ***');\n\n    bits = [];\n    lookupDelim = lookupDelim || '.';\n    var bit = '';\n    var states = [null];\n    var escaped = false;\n    var ch = null;\n    for (var i = 0; i < lookup.length; ++i) {\n        var ch = lookup[i];\n        debug('-- i=' + i + ', ch=' + JSON.stringify(ch) + ' escaped=' +\n            JSON.stringify(escaped));\n        debug('states: ' + JSON.stringify(states));\n\n        // Handle a *limited subset* of JS string escapes.\n        // JSSTYLED\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#Escape_notation\n        var SUPPORTED_ESCAPES = {\n            '\\'': '\\'',\n            '\\\"': '\\\"',\n            '\\`': '\\`',\n            '\\\\': '\\\\',\n            'n': '\\n',\n            'r': '\\r',\n            't': '\\t',\n            'v': '\\v',\n            'b': '\\b',\n            'f': '\\f'\n        };\n        if (ch === '\\\\' && i+1 < lookup.length) {\n            var nextCh = lookup[i+1];\n            var escapedCh = SUPPORTED_ESCAPES[nextCh];\n            if (escapedCh !== undefined) {\n                debug('escaped: %j -> %j', ch+nextCh, escapedCh);\n                bit += escapedCh;\n                i++;\n                continue;\n            }\n        }\n\n        switch (states[states.length - 1]) {\n        case null:\n            switch (ch) {\n            case '\"':\n            case '\\'':\n                states.push(ch);\n                bit += ch;\n                break;\n            case '[':\n                states.push(ch);\n                if (bit !== '') {\n                    bits.push(bit);\n                    bit = ''\n                }\n                bit += ch;\n                break;\n            case lookupDelim:\n                if (bit !== '') {\n                    bits.push(bit);\n                    bit = ''\n                }\n                break;\n            default:\n                bit += ch;\n                break;\n            }\n            break;\n\n        case '[':\n            bit += ch;\n            switch (ch) {\n            case '\"':\n            case '\\'':\n            case '[':\n                states.push(ch);\n                break;\n            case ']':\n                states.pop();\n                if (states[states.length - 1] === null) {\n                    // `bit` is a bracketed string, `[...]`.\n                    //\n                    // The *intent* is to allow specifying an object key\n                    // that would otherwise get interpreted by `json`s\n                    // LOOKUP parsing -- typically if the key has a `.` in it.\n                    //\n                    // Up to and including json v9, this was handled by eval'ing\n                    // the given string inside the brackets (via\n                    // `vm.runInNewContext`). However, trentm/json#144 shows\n                    // that this is an avenue for command injection. It was\n                    // never made clear in `json` documentation that one\n                    // should never use user-provided strings for LOOKUPs, so\n                    // we should close this vulnerability.\n                    //\n                    // Expected usage and documented examples are like this:\n                    //      [\"foo.bar\"]\n                    //      ['foo.bar']\n                    // However, older implementation of eval'ing meant that\n                    // things like the following worked:\n                    //      [42]\n                    //      [\"my\" + \"key\"]\n                    //      [(function () { return \"mykey\" })()]\n                    //\n                    // The documentation was never explicit about denying\n                    // expressions would work. v10 **breaks compatibility**\n                    // to only support a bracketed string:\n                    //      [\"...\"]\n                    //      ['...']\n                    //      [`...`]   # note: no var interpolation is done\n                    // and error otherwise.\n                    var VALID_QUOTES = '\"\\'`';\n                    var sQuote = bit[1];\n                    var eQuote = bit.slice(-2, -1);\n                    if (VALID_QUOTES.indexOf(sQuote) === -1 ||\n                        sQuote !== eQuote)\n                    {\n                        throw new Error(format('invalid bracketed lookup ' +\n                            'string: %j (must be of the form [\\'...\\'], ' +\n                            '[\"...\"], or [`...`])', bit));\n                    }\n                    bits.push(bit.slice(2, -2));\n                    bit = ''\n                }\n                break;\n            }\n            break;\n\n        case '\"':\n            bit += ch;\n            switch (ch) {\n            case '\"':\n                states.pop();\n                if (states[states.length - 1] === null) {\n                    bits.push(bit);\n                    bit = ''\n                }\n                break;\n            }\n            break;\n\n        case '\\'':\n            bit += ch;\n            switch (ch) {\n            case '\\'':\n                states.pop();\n                if (states[states.length - 1] === null) {\n                    bits.push(bit);\n                    bit = ''\n                }\n                break;\n            }\n            break;\n        }\n        debug('bit: ' + JSON.stringify(bit));\n        debug('bits: ' + JSON.stringify(bits));\n    }\n\n    if (bit !== '') {\n        bits.push(bit);\n        bit = ''\n    }\n\n    // Negative-intify: strings that are negative ints we change to a Number for\n    // special handling in `lookupDatum`: Python-style negative array indexing.\n    var negIntPat = /^-\\d+$/;\n    for (var i = 0; i < bits.length; i++) {\n        if (negIntPat.test(bits[i])) {\n            bits[i] = Number(bits[i]);\n        }\n    }\n\n    debug(JSON.stringify(lookup) + ' -> ' + JSON.stringify(bits));\n    return bits\n}\n\n\n/**\n * Parse the given stdin input into:\n *  {\n *    'error': ... error object if there was an error ...,\n *    'datum': ... parsed object if content was JSON ...\n *   }\n *\n * @param buffer {String} The text to parse as JSON.\n * @param obj {Object} Optional. Set when in streaming mode to avoid\n *    re-interpretation of `group`. Also avoids reparsing.\n * @param group {Boolean} Default false. If true, then non-JSON input\n *    will be attempted to be 'arrayified' (see inline comment).\n * @param merge {Boolean} Default null. Can be 'shallow' or 'deep'. An\n *    attempt will be made to interpret the input as adjacent objects to\n *    be merged, last key wins. See inline comment for limitations.\n */\nfunction parseInput(buffer, obj, group, merge) {\n    if (obj) {\n        return {\n            datum: obj\n        };\n    } else if (group) {\n        /**\n         * Special case: Grouping (previously called auto-arrayification)\n         * of unjoined list of objects:\n         *    {\"one\": 1}{\"two\": 2}\n         * and auto-concatenation of unjoined list of arrays:\n         *    [\"a\", \"b\"][\"c\", \"d\"]\n         *\n         * This can be nice to process a stream of JSON objects generated from\n         * multiple calls to another tool or `cat *.json | json`.\n         *\n         * Rules:\n         * - Only JS objects and arrays. Don't see strong need for basic\n         *   JS types right now and this limitation simplifies.\n         * - The break between JS objects has to include a newline:\n         *      {\"one\": 1}\n         *      {\"two\": 2}\n         *   or no spaces at all:\n         *      {\"one\": 1}{\"two\": 2}\n         *   I.e., not this:\n         *      {\"one\": 1}  {\"two\": 2}\n         *   This condition should be fine for typical use cases and ensures\n         *   no false matches inside JS strings.\n         * - The break between JS *arrays* has to include a newline:\n         *      [\"one\", \"two\"]\n         *      [\"three\"]\n         *   The 'no spaces' case is NOT supported for JS arrays as of v6.0.0\n         *   because <https://github.com/trentm/json/issues/55> shows that that\n         *   is not safe.\n         */\n        var newBuffer = buffer;\n        /* JSSTYLED */\n        [/(})\\s*\\n\\s*({)/g, /(})({\")/g].forEach(function (pat) {\n            newBuffer = newBuffer.replace(pat, '$1,\\n$2');\n        });\n        [/(\\])\\s*\\n\\s*(\\[)/g].forEach(function (pat) {\n            newBuffer = newBuffer.replace(pat, ',\\n');\n        });\n        newBuffer = newBuffer.trim();\n        if (newBuffer[0] !== '[') {\n            newBuffer = '[\\n' + newBuffer;\n        }\n        if (newBuffer.slice(-1) !== ']') {\n            newBuffer = newBuffer + '\\n]\\n';\n        }\n        try {\n            return {\n                datum: JSON.parse(newBuffer)\n            };\n        } catch (e2) {\n            return {\n                error: e2\n            };\n        }\n    } else if (merge) {\n        // See the 'Rules' above for limitations on boundaries for 'adjacent'\n        // objects: KISS.\n        var newBuffer = buffer;\n        /* JSSTYLED */\n        [/(})\\s*\\n\\s*({)/g, /(})({\")/g].forEach(function (pat) {\n            newBuffer = newBuffer.replace(pat, '$1,\\n$2');\n        });\n        newBuffer = '[\\n' + newBuffer + '\\n]\\n';\n        var objs;\n        try {\n            objs = JSON.parse(newBuffer);\n        } catch (e) {\n            return {\n                error: e\n            };\n        }\n        var merged = objs[0];\n        if (merge === 'shallow') {\n            for (var i = 1; i < objs.length; i++) {\n                var obj = objs[i];\n                Object.keys(obj).forEach(function (k) {\n                    merged[k] = obj[k];\n                });\n            }\n        } else if (merge === 'deep') {\n            function deepExtend(a, b) {\n                Object.keys(b).forEach(function (k) {\n                    if (a[k] && b[k] &&\n                        toString.call(a[k]) === '[object Object]' &&\n                        toString.call(b[k]) === '[object Object]')\n                    {\n                        deepExtend(a[k], b[k])\n                    } else {\n                        a[k] = b[k];\n                    }\n                });\n            }\n            for (var i = 1; i < objs.length; i++) {\n                deepExtend(merged, objs[i]);\n            }\n        } else {\n            throw new Error(format('unknown value for \"merge\": \"%s\"', merge));\n        }\n        return {\n            datum: merged\n        };\n    } else {\n        try {\n            return {\n                datum: JSON.parse(buffer)\n            };\n        } catch (e) {\n            return {\n                error: e\n            };\n        }\n    }\n}\n\n\n/**\n * Apply a lookup to the given datum.\n *\n * @argument datum {Object}\n * @argument lookup {Array} The parsed lookup (from\n *    `parseLookup(<string>, <string>)`). Might be empty.\n * @returns {Object} The result of the lookup.\n */\nfunction lookupDatum(datum, lookup) {\n    var d = datum;\n    for (var i = 0; i < lookup.length; i++) {\n        var bit = lookup[i];\n        if (d === null) {\n            return undefined;\n        } else if (typeof (bit) === 'number' && bit < 0) {\n            d = d[d.length + bit];\n        } else {\n            d = d[bit];\n        }\n        if (d === undefined) {\n            return undefined;\n        }\n    }\n    return d;\n}\n\n\n/**\n * Output the given datasets.\n *\n * @param datasets {Array} Array of data sets to print, in the form:\n *    `[ [<datum>, <sep>, <alwaysPrintSep>], ... ]`\n * @param filename {String} The filename to which to write the output. If\n *    not set, then emit to stdout.\n * @param headers {String} The HTTP header block string, if any, to emit\n *    first.\n * @param opts {Object} Parsed tool options.\n */\nfunction printDatasets(datasets, filename, headers, opts) {\n    var isTTY = (filename ? false : process.stdout.isTTY)\n    var write = emit;\n    if (filename) {\n        var tmpPath = path.resolve(path.dirname(filename),\n            format('.%s-json-%s-%s.tmp', path.basename(filename), process.pid,\n                Date.now()));\n        var stats = fs.statSync(filename);\n        var f = fs.createWriteStream(tmpPath,\n            {encoding: 'utf8', mode: stats.mode});\n        write = f.write.bind(f);\n    }\n    if (headers && headers.length > 0) {\n        write(headers)\n    }\n    for (var i = 0; i < datasets.length; i++) {\n        var dataset = datasets[i];\n        var output = stringifyDatum(dataset[0], opts, isTTY);\n        var sep = dataset[1];\n        if (output && output.length) {\n            write(output);\n            write(sep);\n        } else if (dataset[2]) {\n            write(sep);\n        }\n    }\n    if (filename) {\n        f.on('open', function () {\n            f.end();\n            fs.renameSync(tmpPath, filename);\n            if (!opts.quiet) {\n                warn('json: updated \"%s\" in-place', filename);\n            }\n        });\n    }\n}\n\n\n/**\n * Stringify the given datum according to the given output options.\n */\nfunction stringifyDatum(datum, opts, isTTY) {\n    var output = null;\n    switch (opts.outputMode) {\n    case OM_INSPECT:\n        output = util.inspect(datum, false, Infinity, isTTY);\n        break;\n    case OM_JSON:\n        if (typeof (datum) !== 'undefined') {\n            output = JSON.stringify(datum, null, opts.jsonIndent);\n        }\n        break;\n    case OM_COMPACT:\n        // Dev Note: A still relatively experimental attempt at a more\n        // compact ouput somewhat a la Python's repr of a dict. I.e. try to\n        // fit elements on one line as much as reasonable.\n        if (datum === undefined) {\n            // pass\n        } else if (Array.isArray(datum)) {\n            var bits = ['[\\n'];\n            datum.forEach(function (d) {\n                bits.push('  ')\n                bits.push(JSON.stringify(d, null, 0).replace(\n                    /* JSSTYLED */\n                    /,\"(?![,:])/g, ', \"'));\n                bits.push(',\\n');\n            });\n            bits.push(bits.pop().slice(0, -2) + '\\n') // drop last comma\n            bits.push(']');\n            output = bits.join('');\n        } else {\n            output = JSON.stringify(datum, null, 0);\n        }\n        break;\n    case OM_JSONY:\n        if (typeof (datum) === 'string') {\n            output = datum;\n        } else if (typeof (datum) !== 'undefined') {\n            output = JSON.stringify(datum, null, opts.jsonIndent);\n        }\n        break;\n    default:\n        throw new Error('unknown output mode: ' + opts.outputMode);\n    }\n    return output;\n}\n\n\n/**\n * Print out a single result, considering input options.\n *\n * @deprecated\n */\nfunction printDatum(datum, opts, sep, alwaysPrintSep) {\n    var output = stringifyDatum(datum, opts);\n    if (output && output.length) {\n        emit(output);\n        emit(sep);\n    } else if (alwaysPrintSep) {\n        emit(sep);\n    }\n}\n\n\nvar stdoutFlushed = true;\nfunction emit(s) {\n    // TODO:PERF If this is try/catch is too slow (too granular): move up to\n    //    mainline and be sure to only catch this particular error.\n    if (drainingStdout) {\n        return;\n    }\n    try {\n        stdoutFlushed = process.stdout.write(s);\n    } catch (e) {\n        // Handle any exceptions in stdout writing in the 'error' event above.\n    }\n}\n\nprocess.stdout.on('error', function (err) {\n    if (err.code === 'EPIPE') {\n        // See <https://github.com/trentm/json/issues/9>.\n        drainStdoutAndExit(0);\n    } else {\n        warn(err)\n        drainStdoutAndExit(1);\n    }\n});\n\n\n/**\n * A hacked up version of 'process.exit' that will first drain stdout\n * before exiting. *WARNING: This doesn't stop event processing.* IOW,\n * callers have to be careful that code following this call isn't\n * accidentally executed.\n *\n * In node v0.6 \"process.stdout and process.stderr are blocking when they\n * refer to regular files or TTY file descriptors.\" However, this hack might\n * still be necessary in a shell pipeline.\n */\nvar drainingStdout = false;\nfunction drainStdoutAndExit(code) {\n    if (drainingStdout) {\n        return;\n    }\n    drainingStdout = true;\n    process.stdout.on('drain', function () {\n        process.exit(code);\n    });\n    process.stdout.on('close', function () {\n        process.exit(code);\n    });\n    if (stdoutFlushed) {\n        process.exit(code);\n    }\n}\n\n\n/**\n * Return a function for the given JS code that returns.\n *\n * If no 'return' in the given javascript snippet, then assume we are a single\n * statement and wrap in 'return (...)'. This is for convenience for short\n * '-c ...' snippets.\n */\nfunction funcWithReturnFromSnippet(js) {\n    // auto-\"return\"\n    if (js.indexOf('return') === -1) {\n        if (js.substring(js.length - 1) === ';') {\n            js = js.substring(0, js.length - 1);\n        }\n        js = 'return (' + js + ')';\n    }\n    return (new Function(js));\n}\n\n\n\n//---- mainline\n\nfunction main(argv) {\n    var opts;\n    try {\n        opts = parseArgv(argv);\n    } catch (e) {\n        warn('json: error: %s', e.message)\n        return drainStdoutAndExit(1);\n    }\n    //warn(opts);\n    if (opts.help) {\n        printHelp();\n        return;\n    }\n    if (opts.version) {\n        if (opts.outputMode === OM_JSON) {\n            var v = {\n                version: getVersion(),\n                author: 'Trent Mick',\n                project: 'https://github.com/trentm/json'\n            };\n            console.log(JSON.stringify(v, null, opts.jsonIndent));\n        } else {\n            console.log('json ' + getVersion());\n            console.log('written by Trent Mick');\n            console.log('https://github.com/trentm/json');\n        }\n        return;\n    }\n    var lookupStrs = opts.args;\n\n    // Prepare condition and execution funcs (and vm scripts) for -c/-e.\n    var execVm = Boolean(process.env.JSON_EXEC &&\n        process.env.JSON_EXEC === 'vm');\n    var i;\n    var condFuncs = [];\n    if (!execVm) {\n        for (i = 0; i < opts.condSnippets.length; i++) {\n            condFuncs[i] = funcWithReturnFromSnippet(opts.condSnippets[i]);\n        }\n    }\n    var condScripts = [];\n    if (execVm) {\n        for (i = 0; i < opts.condSnippets.length; i++) {\n            condScripts[i] = vm.createScript(opts.condSnippets[i]);\n        }\n    }\n    var cond = Boolean(condFuncs.length + condScripts.length);\n    var exeFuncs = [];\n    if (!execVm) {\n        for (i = 0; i < opts.exeSnippets.length; i++) {\n            exeFuncs[i] = new Function(opts.exeSnippets[i]);\n        }\n    }\n    var exeScripts = [];\n    if (execVm) {\n        for (i = 0; i < opts.exeSnippets.length; i++) {\n            exeScripts[i] = vm.createScript(opts.exeSnippets[i]);\n        }\n    }\n    var exe = Boolean(exeFuncs.length + exeScripts.length);\n\n    try {\n        var lookups = lookupStrs.map(function (lookup) {\n            return parseLookup(lookup, opts.lookupDelim);\n        });\n    } catch (e) {\n        warn('json: error: %s', e.message)\n        return drainStdoutAndExit(1);\n    }\n\n    if (opts.group && opts.array && opts.outputMode !== OM_JSON) {\n        // streaming\n        var chunker = chunkEmitter(opts);\n        chunker.on('error', function (error) {\n            warn('json: error: %s', err.message);\n            return drainStdoutAndExit(1);\n        });\n        chunker.on('chunk', parseChunk);\n    } else if (opts.inPlace) {\n        assert.equal(opts.inputFiles.length, 1,\n            'cannot handle more than one file with -I');\n        getInput(opts, function (err, content, filename) {\n            if (err) {\n                warn('json: error: %s', err.message)\n                return drainStdoutAndExit(1);\n            }\n\n            // Take off a leading HTTP header if any and pass it through.\n            var headers = [];\n            while (true) {\n                if (content.slice(0, 5) === 'HTTP/') {\n                    var index = content.indexOf('\\r\\n\\r\\n');\n                    var sepLen = 4;\n                    if (index == -1) {\n                        index = content.indexOf('\\n\\n');\n                        sepLen = 2;\n                    }\n                    if (index != -1) {\n                        if (!opts.dropHeaders) {\n                            headers.push(content.slice(0, index + sepLen));\n                        }\n                        var is100Continue = (\n                            content.slice(0, 21) === 'HTTP/1.1 100 Continue');\n                        content = content.slice(index + sepLen);\n                        if (is100Continue) {\n                            continue;\n                        }\n                    }\n                }\n                break;\n            }\n            parseChunk(content, undefined, filename, true, headers.join(''));\n        });\n    } else {\n        // not streaming\n        getInput(opts, function (err, buffer, filename) {\n            if (err) {\n                warn('json: error: %s', err.message)\n                return drainStdoutAndExit(1);\n            }\n            // Take off a leading HTTP header if any and pass it through.\n            while (true) {\n                if (buffer.slice(0, 5) === 'HTTP/') {\n                    var index = buffer.indexOf('\\r\\n\\r\\n');\n                    var sepLen = 4;\n                    if (index == -1) {\n                        index = buffer.indexOf('\\n\\n');\n                        sepLen = 2;\n                    }\n                    if (index != -1) {\n                        if (!opts.dropHeaders) {\n                            emit(buffer.slice(0, index + sepLen));\n                        }\n                        var is100Continue = (\n                            buffer.slice(0, 21) === 'HTTP/1.1 100 Continue');\n                        buffer = buffer.slice(index + sepLen);\n                        if (is100Continue) {\n                            continue;\n                        }\n                    }\n                }\n                break;\n            }\n            parseChunk(buffer, null, filename, false);\n        });\n    }\n\n    /**\n     * Parse a single chunk of JSON. This may be called more than once\n     * (when streaming or when operating on multiple files).\n     *\n     * @param chunk {String} The JSON-encoded string.\n     * @param obj {Object} Optional. For some code paths while streaming `obj`\n     *    will be provided. This is an already parsed JSON object.\n     * @param filename {String} Optional. The filename from which this content\n     *    came, if relevant.\n     * @param inPlace {Boolean} Optional. If true, then output will be written\n     *    to `filename`.\n     * @param headers {String} Optional. Leading HTTP headers, if any to emit.\n     */\n    function parseChunk(chunk, obj, filename, inPlace, headers) {\n        // Expect the chunk to be JSON.\n        if (!chunk.length) {\n            return;\n        }\n        // parseInput() -> {datum: <input object>, error: <error object>}\n        var input = parseInput(chunk, obj, opts.group, opts.merge);\n        if (input.error) {\n            // Doesn't look like JSON. Just print it out and move on.\n            if (!opts.quiet) {\n                // Use JSON-js' \"json_parse\" parser to get more detail on the\n                // syntax error.\n                var details = '';\n                var normBuffer = chunk.replace(/\\r\\n|\\n|\\r/, '\\n');\n                try {\n                    json_parse(normBuffer);\n                    details = input.error;\n                } catch (err) {\n                    // err.at has the position. Get line/column from that.\n                    var at = err.at - 1; // `err.at` looks to be 1-based.\n                    var lines = chunk.split('\\n');\n                    var line, col, pos = 0;\n                    for (line = 0; line < lines.length; line++) {\n                        pos += lines[line].length + 1;\n                        if (pos > at) {\n                            col = at - (pos - lines[line].length - 1);\n                            break;\n                        }\n                    }\n                    var spaces = '';\n                    for (var i = 0; i < col; i++) {\n                        spaces += '.';\n                    }\n                    details = err.message + ' at line ' + (line + 1) +\n                        ', column ' + (col + 1) + ':\\n        ' +\n                        lines[line] + '\\n        ' + spaces + '^';\n                }\n                warn('json: error: %s is not JSON: %s',\n                    filename ? '\"' + filename + '\"' : 'input', details);\n            }\n            if (!opts.validate) {\n                emit(chunk);\n                if (chunk.length && chunk[chunk.length - 1] !== '\\n') {\n                    emit('\\n');\n                }\n            }\n            return drainStdoutAndExit(1);\n        }\n        if (opts.validate) {\n            return drainStdoutAndExit(0);\n        }\n        var data = input.datum;\n\n        // Process: items (-M, --items)\n        if (opts.items) {\n            if (!Array.isArray(data)) {\n                var key;\n                var array = [];\n                for (key in data) {\n                    if (data.hasOwnProperty(key)) {\n                        array.push({\n                          key: key,\n                          value: data[key]\n                        });\n                    }\n                }\n                data = array;\n            }\n        }\n\n        // Process: executions (-e, -E)\n        var i, j;\n        if (!exe) {\n            /* pass */\n        } else if (opts.array || (opts.array === null && Array.isArray(data))) {\n            var arrayified = false;\n            if (!Array.isArray(data)) {\n                arrayified = true;\n                data = [data];\n            }\n            for (i = 0; i < data.length; i++) {\n                var datum = data[i];\n                for (j = 0; j < exeFuncs.length; j++) {\n                    exeFuncs[j].call(datum);\n                }\n                for (j = 0; j < exeScripts.length; j++) {\n                    exeScripts[j].runInNewContext(datum);\n                }\n            }\n            if (arrayified) {\n                data = data[0];\n            }\n        } else {\n            for (j = 0; j < exeFuncs.length; j++) {\n                exeFuncs[j].call(data);\n            }\n            for (j = 0; j < exeScripts.length; j++) {\n                exeScripts[j].runInNewContext(data);\n            }\n        }\n\n        // Process: conditionals (-c)\n        if (!cond) {\n            /* pass */\n        } else if (opts.array || (opts.array === null && Array.isArray(data))) {\n            var arrayified = false;\n            if (!Array.isArray(data)) {\n                arrayified = true;\n                data = [data];\n            }\n            var filtered = [];\n            for (i = 0; i < data.length; i++) {\n                var datum = data[i];\n                var datumCopy = objCopy(datum);\n                var keep = true;\n                // TODO(perf): Perhaps drop the 'datumCopy'? \"this is a gun\"\n                for (j = 0; j < condFuncs.length; j++) {\n                    if (!condFuncs[j].call(datumCopy)) {\n                        keep = false;\n                        break;\n                    }\n                }\n                if (keep) {\n                    for (j = 0; j < condScripts.length; j++) {\n                        if (!condScripts[j].runInNewContext(datumCopy)) {\n                            keep = false;\n                            break;\n                        }\n                    }\n                    if (keep) {\n                        filtered.push(datum);\n                    }\n                }\n            }\n            if (arrayified) {\n                data = (filtered.length ? filtered[0] : []);\n            } else {\n                data = filtered;\n            }\n        } else {\n            var keep = true;\n            var dataCopy = objCopy(data);\n            for (j = 0; j < condFuncs.length; j++) {\n                // TODO(perf): Perhaps drop the 'dataCopy'? \"this is a gun\"\n                if (!condFuncs[j].call(dataCopy)) {\n                    keep = false;\n                    break;\n                }\n            }\n            if (keep) {\n                for (j = 0; j < condScripts.length; j++) {\n                    if (!condScripts[j].runInNewContext(dataCopy)) {\n                        keep = false;\n                        break;\n                    }\n                }\n            }\n            if (!keep) {\n                data = undefined;\n            }\n        }\n\n        // Process: lookups\n        var lookupsAreIndeces = false;\n        if (lookups.length) {\n            if (opts.array) {\n                if (!Array.isArray(data)) data = [data];\n                var table = [];\n                for (j = 0; j < data.length; j++) {\n                    var datum = data[j];\n                    var row = {};\n                    for (i = 0; i < lookups.length; i++) {\n                        var lookup = lookups[i];\n                        var value = lookupDatum(datum, lookup);\n                        if (value !== undefined) {\n                            row[lookup.join('.')] = value;\n                        }\n                    }\n                    table.push(row);\n                }\n                data = table;\n            } else {\n                // Special case handling: Note if the 'lookups' are indeces into\n                // an array. This may be used below to change the output\n                // representation.\n                if (Array.isArray(data)) {\n                    lookupsAreIndeces = true;\n                    for (i = 0; i < lookups.length; i++) {\n                        if (lookups[i].length !== 1 ||\n                            isNaN(Number(lookups[i])))\n                        {\n                            lookupsAreIndeces = false;\n                            break;\n                        }\n                    }\n                }\n                var row = {};\n                for (i = 0; i < lookups.length; i++) {\n                    var lookup = lookups[i];\n                    var value = lookupDatum(data, lookup);\n                    if (value !== undefined) {\n                        row[lookup.join('.')] = value;\n                    }\n                }\n                data = row;\n            }\n        }\n\n        // --keys\n        if (opts.outputKeys) {\n            var data = Object.keys(data);\n        }\n\n        // Output\n        var datasets = [];\n        if (opts.outputMode === OM_JSON) {\n            if (lookups.length === 1 && !opts.array) {\n                /**\n                 * Special case: For JSON output of a *single* lookup, *don't*\n                 * use the full table structure, else there is no way to get\n                 * string quoting for a single value:\n                 *      $ echo '{\"a\": [], \"b\": \"[]\"}' | json -j a\n                 *      []\n                 *      $ echo '{\"a\": [], \"b\": \"[]\"}' | json -j b\n                 *      '[]'\n                 * See <https://github.com/trentm/json/issues/35> for why.\n                 */\n                data = data[lookups[0].join('.')];\n            } else if (lookupsAreIndeces) {\n                /**\n                 * Special case: Lookups that are all indeces into an input\n                 * array are more likely to be wanted as an array of selected\n                 * items rather than a 'JSON table' thing that we use otherwise.\n                 */\n                var flattened = [];\n                for (i = 0; i < lookups.length; i++) {\n                    var lookupStr = lookups[i].join('.');\n                    if (data.hasOwnProperty(lookupStr)) {\n                        flattened.push(data[lookupStr])\n                    }\n                }\n                data = flattened;\n            }\n            // If JSON output mode, then always just output full set of data to\n            // ensure valid JSON output.\n            datasets.push([data, '\\n', false]);\n        } else if (lookups.length) {\n            if (opts.array) {\n                // Output `data` as a 'table' of lookup results.\n                for (j = 0; j < data.length; j++) {\n                    var row = data[j];\n                    for (i = 0; i < lookups.length - 1; i++) {\n                        datasets.push([row[lookups[i].join('.')],\n                            opts.delim, true]);\n                    }\n                    datasets.push([row[lookups[i].join('.')], '\\n', true]);\n                }\n            } else {\n                for (i = 0; i < lookups.length; i++) {\n                    datasets.push([data[lookups[i].join('.')], '\\n', false]);\n                }\n            }\n        } else if (opts.array) {\n            if (!Array.isArray(data)) data = [data];\n            for (j = 0; j < data.length; j++) {\n                datasets.push([data[j], '\\n', false]);\n            }\n        } else {\n            // Output `data` as is.\n            datasets.push([data, '\\n', false]);\n        }\n        printDatasets(datasets, inPlace ? filename : undefined, headers, opts);\n    }\n}\n\nif (require.main === module) {\n    // HACK guard for <https://github.com/trentm/json/issues/24>.\n    // We override the `process.stdout.end` guard that core node.js puts in\n    // place. The real fix is that `.end()` shouldn't be called on stdout\n    // in node core. Hopefully node v0.6.9 will fix that. Only guard\n    // for v0.6.0..v0.6.8.\n    var nodeVer = process.versions.node.split('.').map(Number);\n    if ([0, 6, 0] <= nodeVer && nodeVer <= [0, 6, 8]) {\n        var stdout = process.stdout;\n        stdout.end = stdout.destroy = stdout.destroySoon = function () {\n            /* pass */\n        };\n    }\n\n    main(process.argv);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}